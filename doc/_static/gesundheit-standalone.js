!function(e){"object"==typeof exports?module.exports=e():"function"==typeof define&&define.amd?define(e):"undefined"!=typeof window?window.gesundheit=e():"undefined"!=typeof global?global.gesundheit=e():"undefined"!=typeof self&&(self.gesundheit=e())}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0

module.exports = function(fn, msg) {
  return function() {
    console.warn('DEPRECATED: ', msg, new Error().stack.split('\n').slice(1).join('\n'));
    return fn.apply(this, arguments);
  };
};

module.exports.rename = function(fn, oldName, newName) {
  return module.exports(fn, "" + oldName + " has been renamed to " + newName + " and will be removed in a future release.");
};

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0

module.exports = function(fn) {
  return function() {
    fn.apply(this, arguments);
    return this;
  };
};

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0

module.exports = function(method) {
  return function(first) {
    if (Array.isArray(first)) {
      return method.call(this, first);
    } else {
      return method.call(this, Array.prototype.slice.call(arguments));
    }
  };
};

},{}],4:[function(require,module,exports){
var process=require("__browserify_process"),__dirname="/";// Generated by CoffeeScript 1.4.0
/*
Dialects are responsible for compiling an AST to a SQL string compatible with
a particular DBMS. They are rarely used directly, instead a query is usually
bound to an `engine <Engines>`_ that will delegate compiling to it's dialect
instance.
*/

var BaseDialect, Delete, Field, Insert, MySQLDialect, PostgresDialect, PrettyDialect, Relation, SQLite3Dialect, Select, Update, keywords, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ref = require('./nodes'), Select = _ref.Select, Update = _ref.Update, Delete = _ref.Delete, Insert = _ref.Insert, Relation = _ref.Relation, Field = _ref.Field;

if (process.browser) {
  keywords = [];
} else {
  keywords = require('fs').readFileSync(__dirname + '/sql_keywords.txt').toString().split('\n').filter(Boolean);
}

BaseDialect = (function() {
  var Visitor, doubleQuote, needsQuote;

  function BaseDialect() {}

  BaseDialect.prototype.reset = function() {};

  BaseDialect.prototype.compile = function(root) {
    var text, visitor;
    visitor = new Visitor(this);
    text = visitor.compile(root);
    return [text, visitor.params];
  };

  BaseDialect.prototype.renderString = function(s) {
    var path;
    path = this.path.map(function(p) {
      var _ref1;
      return (_ref1 = p.constructor) != null ? _ref1.name : void 0;
    }).join(' > ');
    this.path = [];
    throw new Error("raw string compiled! " + path);
  };

  needsQuote = /\s|"|\./;

  doubleQuote = /"/g;

  BaseDialect.prototype.quote = function(s) {
    if ((s != null ? s.match(needsQuote) : void 0) || this.isKeyword(s)) {
      return '"' + s.replace(doubleQuote, '\\"') + '"';
    } else {
      return s;
    }
  };

  BaseDialect.prototype.isKeyword = function(word) {
    return keywords.indexOf(word.toUpperCase()) !== -1;
  };

  BaseDialect.prototype.operator = function(op) {
    switch ((op = op.toUpperCase())) {
      case 'NE':
      case '!=':
      case '<>':
        return '!=';
      case 'EQ':
      case '=':
        return '=';
      case 'LT':
      case '<':
        return '<';
      case 'GT':
      case '>':
        return '>';
      case 'LTE':
      case '<=':
        return '<=';
      case 'GTE':
      case '>=':
        return '>=';
      case 'LIKE':
      case 'ILIKE':
      case 'IN':
      case 'NOT IN':
      case 'IS':
      case 'IS NOT':
        return op;
      default:
        throw new Error("Unsupported comparison operator: " + op);
    }
  };

  BaseDialect.prototype.placeholder = function(position) {
    return "$" + position;
  };

  Visitor = (function() {

    function Visitor(dialect) {
      this.dialect = dialect;
      this.path = [];
      this.params = [];
    }

    Visitor.prototype.compile = function(node, allowOverride) {
      var custom, name, string, _ref1, _ref2;
      if (allowOverride == null) {
        allowOverride = true;
      }
      this.path.push(node);
      name = node != null ? (_ref1 = node.__proto__) != null ? (_ref2 = _ref1.constructor) != null ? _ref2.name : void 0 : void 0 : void 0;
      if (allowOverride && name && (custom = this.dialect['render' + name])) {
        string = custom.call(this, node);
      } else {
        string = node.compile(this, this.path);
      }
      this.path.pop(node);
      return string;
    };

    Visitor.prototype.maybeParens = function(it) {
      if (/\s/.exec(it)) {
        return "(" + it + ")";
      } else {
        return it;
      }
    };

    Visitor.prototype.operator = function(string) {
      return this.dialect.operator(string);
    };

    Visitor.prototype.parameter = function(val) {
      this.params.push(val);
      return this.dialect.placeholder(this.params.length);
    };

    Visitor.prototype.quote = function(string) {
      return this.dialect.quote(string, this.path);
    };

    return Visitor;

  })();

  return BaseDialect;

})();

PrettyDialect = (function(_super) {

  __extends(PrettyDialect, _super);

  function PrettyDialect() {
    return PrettyDialect.__super__.constructor.apply(this, arguments);
  }

  PrettyDialect.prototype.renderJoin = function(node) {
    return "\n" + this.compile(node, false);
  };

  PrettyDialect.prototype.renderWhere = function(node) {
    return "\n" + this.compile(node, false);
  };

  PrettyDialect.prototype.renderHaving = function(node) {
    return "\n" + this.compile(node, false);
  };

  PrettyDialect.prototype.renderOrderBy = function(node) {
    return "\n" + this.compile(node, false);
  };

  PrettyDialect.prototype.renderGroupBy = function(node) {
    return "\n" + this.compile(node, false);
  };

  PrettyDialect.prototype.renderRelationSet = function(node) {
    return "\n" + this.compile(node, false);
  };

  PrettyDialect.prototype.renderSelectColumnSet = function(node) {
    var glue, last, lines, size, text, thisLine, thisLineLength, _i, _len, _ref1;
    glue = node.glue;
    last = node.nodes.length;
    lines = [];
    thisLine = [];
    thisLineLength = 81;
    _ref1 = node.nodes;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      text = this.compile(node);
      size = text.length + glue.length;
      if (thisLineLength + size > 50) {
        lines.push(thisLine.join(glue));
        thisLine = [];
        thisLineLength = 0;
      }
      thisLineLength += size;
      thisLine.push(text);
    }
    lines.shift();
    lines.push(thisLine.join(glue));
    return lines.join("\n  ");
  };

  return PrettyDialect;

})(BaseDialect);

PostgresDialect = (function(_super) {

  __extends(PostgresDialect, _super);

  function PostgresDialect() {
    return PostgresDialect.__super__.constructor.apply(this, arguments);
  }

  PostgresDialect.prototype.operator = function(op) {
    switch (op.toLowerCase()) {
      case 'hasKey':
      case '?':
        return '?';
      case 'contains':
      case '@>':
        return '@>';
      case '->':
        return '->';
      default:
        return PostgresDialect.__super__.operator.call(this, op);
    }
  };

  PostgresDialect.prototype.isKeyword = function(s) {
    return (s != null) && s !== '*';
  };

  return PostgresDialect;

})(BaseDialect);

MySQLDialect = (function(_super) {

  __extends(MySQLDialect, _super);

  function MySQLDialect() {
    return MySQLDialect.__super__.constructor.apply(this, arguments);
  }

  MySQLDialect.prototype.placeholder = function() {
    return '?';
  };

  MySQLDialect.prototype.quote = function(s, path) {
    /*
        MySQL has two special cases for quoting:
         - The column names in an insert column list are not quoted
         - table and field names are quoted with backticks.
    */

    var node;
    node = path[path.length - 1];
    if (s === '*' || path.some(function(node) {
      return node instanceof Insert.ColumnList;
    })) {
      return s;
    } else if (node instanceof Field || node instanceof Relation) {
      return "`" + s + "`";
    } else {
      return MySQLDialect.__super__.quote.apply(this, arguments);
    }
  };

  return MySQLDialect;

})(BaseDialect);

SQLite3Dialect = (function(_super) {

  __extends(SQLite3Dialect, _super);

  function SQLite3Dialect() {
    return SQLite3Dialect.__super__.constructor.apply(this, arguments);
  }

  SQLite3Dialect.prototype.placeholder = function() {
    return '?';
  };

  SQLite3Dialect.prototype.renderInsertData = function(node) {
    var string;
    if (node.nodes.length < 2) {
      return node.compile(this, this.path);
    } else {
      node.glue = ' UNION ALL SELECT ';
      string = node.compile(this, this.path).replace('VALUES', 'SELECT').replace(/[()]/g, '');
      node.glue = ', ';
      return string;
    }
  };

  return SQLite3Dialect;

})(BaseDialect);

module.exports = {
  base: BaseDialect,
  pretty: PrettyDialect,
  postgres: PostgresDialect,
  mysql: MySQLDialect,
  sqlite3: SQLite3Dialect
};

},{"./nodes":7,"__browserify_process":33,"fs":25}],5:[function(require,module,exports){
var process=require("__browserify_process");// Generated by CoffeeScript 1.4.0
var Engine, anyDB, begin, dialects, fakePool, queries, url;

url = require('url');

anyDB = require('any-db');

begin = require('any-db-transaction');

queries = require('./queries/index');

dialects = require('./dialects');

module.exports = function() {
  return Engine.create.apply(Engine, arguments);
};

Engine = (function() {
  /*
    ``Engine`` is gesundheits interface to an actual database.
  
    Engines have all of the :ref:`query factory functions <query-factories>`
    attached to them as instance methods that automatically bind created queries
    to the engine. They also have these additionaly methods
  */

  Engine.create = function(dbUrl, poolOptions) {
    /*
        Create an :class:`engine::Engine` instance from an Any-DB_ connect string
        and extra connection pool options, this is exported by gesundheit as
        ``gesundheit.engine(...)``.
    
        :ref:`This example <engine-usage-example>` shows the most common way to set up
        a single default database engine for an application.
    
        .. _Any-DB: https://github.com/grncdr/node-any-db
        .. _Any-DB ConnectionPool: https://github.com/grncdr/node-any-db/blob/master/API.md#connectionpool
    */

    var dialectType, driverName, parsed, pool;
    parsed = url.parse(dbUrl);
    driverName = parsed.protocol.replace(':', '').split('+').shift();
    if (driverName === 'fake') {
      pool = fakePool();
      if (parsed.protocol.match('pretty')) {
        dialectType = dialects.pretty;
      } else {
        dialectType = dialects.base;
      }
    } else {
      pool = anyDB.createPool(dbUrl, poolOptions);
      dialectType = dialects[driverName];
    }
    if (!(dialectType != null)) {
      throw new Error('no such dialect: ' + driverName);
    }
    return new Engine(driverName, dbUrl, pool, new dialectType());
  };

  function Engine(driver, url, pool, dialect) {
    this.driver = driver;
    this.url = url;
    this.pool = pool;
    this.dialect = dialect;
    queries.mixinFactoryMethods(this);
  }

  Engine.prototype.query = function(statement, params, callback) {
    /*
        Passes arguments directly to the query method of the underlying `Any-DB
        ConnectionPool`_
    */

    var _ref;
    return (_ref = this.pool).query.apply(_ref, arguments);
  };

  Engine.prototype.begin = function(callback) {
    /*
        Start a new transaction and return it.
    
        The returned object behaves exactly like a new engine, but has ``commit``
        and ``rollback`` methods instead of ``close``. (In fact it's an `Any-DB
        Transaction`_ that has had the query factory functions mixed in to it).
    
        .. _Any-DB Transaction: https://github.com/grncdr/node-any-db/blob/master/API.md#transaction
    */

    var tx;
    tx = queries.mixinFactoryMethods(begin(this.pool, callback));
    tx.begin = function(cb) {
      var child;
      child = begin(tx, cb);
      child.engine = tx.engine;
      child.compile = tx.compile;
      return queries.mixinFactoryMethods(child);
    };
    tx.engine = this;
    tx.compile = this.dialect.compile.bind(this.dialect);
    return tx;
  };

  Engine.prototype.compile = function(root) {
    /*
        Render an AST to a SQL string and collect parameters
    */
    return this.dialect.compile(root);
  };

  Engine.prototype.close = function() {
    /*
        Closes the internal connection pool.
    */
    return this.pool.close();
  };

  return Engine;

})();

fakePool = function() {
  /*
    Create a fake database connection pool that throws errors if you try to
    execute a query.
  */
  return {
    begin: function(cb) {
      if (cb) {
        process.nextTick(cb.bind(null, engine));
      }
      return engine;
    },
    query: function(sql, params, cb) {
      throw new Error("Cannot query with fakeEngine. Do `gesundheit.defaultEngine = gesundheit.engine(url)` before querying");
    },
    close: function() {}
  };
};

},{"./dialects":4,"./queries/index":10,"__browserify_process":33,"any-db":32,"any-db-transaction":21,"url":27}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
/*
There are a few subsystems that make up gesundheit, but the majority of use
cases will be covered by using the following properties of the main module:

  **gesundheit.{Select, SELECT, select}**
    Function for creating new :class:`queries/select::SelectQuery` instances.

  **gesundheit.{Update, UPDATE, update}**
    Function for creating new :class:`queries/update::UpdateQuery` instances.

  **gesundheit.{Delete, DELETE, delete}**
    Function for creating new :class:`queries/delete::DeleteQuery` instances.

  **gesundheit.{Insert, INSERT, insert}**
    Function for creating new :class:`queries/insert::InsertQuery` instances.

  **gesundheit.engine**
    Function for creating new :mod:`engines`.

  **gesundheit.defaultEngine**
    The engine that will be used for queries that aren't explicitly bound. This
    is set to a no-op engine that you will want to replace with either an object
    returned by the ``gesundheit.engine`` function or by implementing the engine
    interface yourself.

  **Join types**
    Constant nodes for use with :meth:`queries/sud::SUDQuery.join`.
    'LEFT', 'RIGHT', 'INNER', 'LEFT_OUTER', 'RIGHT_OUTER', 'FULL_OUTER'
    'NATURAL', 'CROSS'

  **AST helper functions**
    These come from the `nodes <#module-nodes::>`_ module and are often useful
    when constructing complicated queries:

      :func:`nodes::toParam`
        Convert any object to a parameter placeholder.
      :func:`nodes::toRelation`
        Convert various inputs to :class:`nodes::Relation` nodes.
      :func:`nodes::binaryOp`
        Create a binary comparison node manually.  (e.g. for postgres' custom
        operators).
      :func:`nodes::sqlFunction`
        Create SQL function calls (e.g. ``MAX(last_update)``)
      :func:`nodes::text`
        Include raw SQL in a query, with parameter placeholders.

If you are implementing support for a different database engine or constructing
particularly unusual SQL statements, you might also want to make use of these:

  **gesundheit.nodes**
    The `nodes <Nodes>` module.

  **gesundheit.dialects**
    The `dialects <Dialects>` module.
*/

var helper, name, node, _ref, _ref1, _ref2,
  __slice = [].slice;

exports.dialects = require('./dialects');

exports.engine = require('./engine');

exports.nodes = require('./nodes');

exports.queries = require('./queries/index');

exports.defaultEngine = exports.engine('fake://localhost/');

exports.queries.mixinFactoryMethods(exports, function() {
  return exports.defaultEngine;
});

_ref = exports.nodes.CONST_NODES;
for (name in _ref) {
  node = _ref[name];
  exports[name] = exports.nodes.CONST_NODES[name];
}

_ref1 = exports.nodes.JOIN_TYPES;
for (name in _ref1) {
  node = _ref1[name];
  exports[name] = exports.nodes.JOIN_TYPES[name];
}

_ref2 = exports.nodes;
for (name in _ref2) {
  helper = _ref2[name];
  if (name[0] === name[0].toLowerCase()) {
    exports[name] = helper;
  }
}

exports.begin = function() {
  var args, _ref3;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return (_ref3 = exports.defaultEngine).begin.apply(_ref3, args);
};

exports.query = function() {
  var args, _ref3;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return (_ref3 = exports.defaultEngine).query.apply(_ref3, args);
};

exports.unmarshaller = require('./unmarshal');

},{"./dialects":4,"./engine":5,"./nodes":7,"./queries/index":10,"./unmarshal":16}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
/*
These are the classes that represent nodes in the AST for a SQL statement.
Application code should very rarely have to deal with these classes directly;
Instead, the APIs exposed by the various query manager classes are intended to
cover the majority of use-cases.

However, in the spirit of "making hard things possible", all of AST nodes are
exported from this module so you can constructed and assemble them manually if
you need to.
*/

var AbstractAlias, And, Binary, CONST_NODES, Column, ColumnAlias, ColumnSet, ComparableMixin, Delete, Distinct, Field, FixedNodeSet, FunctionAlias, GroupBy, Having, Identifier, Insert, IntegerNode, JOIN_TYPES, Join, JoinType, Limit, Node, NodeSet, Offset, Or, OrderBy, Ordering, Parameter, ParenthesizedNodeSet, Prefixed, PrefixedAlias, Relation, RelationAlias, RelationSet, Returning, Select, SelectColumnSet, SqlFunction, Statement, SubQuery, SubQueryAlias, TextAlias, TextNode, Tuple, Update, ValueNode, Where, binaryOp, copy, ctor, exists, func, getAlias, merge, name, notExists, sqlFunction, text, toColumn, toField, toParam, toProjection, toRelation, tuple, unmarshal, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

Node = (function() {

  function Node() {}

  /* (Empty) base Node class
  */


  Node.prototype.compile = function(dialect) {
    var message;
    message = "" + this.constructor + " has no compile method. Parents: " + dialect.path;
    throw new Error(message);
  };

  Node.prototype.toJSON = function() {
    return {
      _type: this.constructor.name
    };
  };

  Node.prototype.copy = function() {
    return unmarshal(this.toJSON());
  };

  return Node;

})();

ValueNode = (function(_super) {

  __extends(ValueNode, _super);

  /* A ValueNode is a literal string that should be printed unescaped.
  */


  ValueNode.unmarshal = function(data, recur) {
    return new this(data.value);
  };

  function ValueNode(value) {
    this.value = value;
    if (this.value != null) {
      if (!this.valid()) {
        throw new Error("Invalid " + this.constructor.name + ": " + this.value);
      }
    }
  }

  ValueNode.prototype.valid = function() {
    return true;
  };

  ValueNode.prototype.compile = function() {
    return this.value;
  };

  ValueNode.prototype.toJSON = function() {
    return merge(ValueNode.__super__.toJSON.apply(this, arguments), {
      value: this.value
    });
  };

  return ValueNode;

})(Node);

IntegerNode = (function(_super) {

  __extends(IntegerNode, _super);

  function IntegerNode() {
    return IntegerNode.__super__.constructor.apply(this, arguments);
  }

  /* A :class:`nodes::ValueNode` that validates it's input is an integer.
  */


  IntegerNode.prototype.valid = function() {
    return !isNaN(this.value = parseInt(this.value));
  };

  return IntegerNode;

})(ValueNode);

Identifier = (function(_super) {

  __extends(Identifier, _super);

  function Identifier() {
    return Identifier.__super__.constructor.apply(this, arguments);
  }

  /*
    An identifier is a column or relation name that may need to be quoted.
  */


  Identifier.prototype.compile = function(dialect) {
    return dialect.quote(this.value);
  };

  return Identifier;

})(ValueNode);

CONST_NODES = {};

_ref = ['DEFAULT', 'NULL', 'IS_NULL', 'IS_NOT_NULL'];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  name = _ref[_i];
  CONST_NODES[name] = new ValueNode(name.replace('_', ' '));
}

JoinType = (function(_super) {

  __extends(JoinType, _super);

  function JoinType() {
    return JoinType.__super__.constructor.apply(this, arguments);
  }

  return JoinType;

})(ValueNode);

JOIN_TYPES = {};

_ref1 = ['LEFT', 'RIGHT', 'INNER', 'LEFT_OUTER', 'RIGHT_OUTER', 'FULL_OUTER', 'NATURAL', 'CROSS'];
for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
  name = _ref1[_j];
  JOIN_TYPES[name] = new JoinType(name.replace('_', ' '));
}

NodeSet = (function(_super) {

  __extends(NodeSet, _super);

  /* A set of nodes joined together by ``@glue``
  */


  NodeSet.unmarshal = function(data, recur) {
    return new this(recur(data.nodes), data.glue);
  };

  function NodeSet(nodes, glue) {
    var node, _k, _len2, _ref2;
    if (glue == null) {
      glue = ' ';
    }
    /*
        :param @nodes: A list of child nodes.
        :param glue: A string that will be used to join the nodes when compileing
    */

    this.nodes = [];
    if (nodes) {
      for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
        node = nodes[_k];
        this.addNode(node);
      }
    }
    if ((_ref2 = this.glue) == null) {
      this.glue = glue;
    }
  }

  NodeSet.prototype.addNode = function(node) {
    /* Add a new Node to the end of this set
    */
    return this.nodes.push(node);
  };

  NodeSet.prototype.compile = function(dialect) {
    var compile;
    compile = dialect.compile.bind(dialect);
    return this.nodes.map(compile).filter(Boolean).join(this.glue);
  };

  NodeSet.prototype.toJSON = function() {
    return merge(NodeSet.__super__.toJSON.apply(this, arguments), {
      glue: this.glue,
      nodes: this.nodes.map(function(n) {
        return n.toJSON();
      })
    });
  };

  return NodeSet;

})(Node);

FixedNodeSet = (function(_super) {

  __extends(FixedNodeSet, _super);

  function FixedNodeSet() {
    FixedNodeSet.__super__.constructor.apply(this, arguments);
    this.addNode = null;
  }

  return FixedNodeSet;

})(NodeSet);

Statement = (function(_super) {

  __extends(Statement, _super);

  Statement.prefix = '';

  Statement.structure = function(structure) {
    var _this = this;
    this._nodeOrder = [];
    return structure.forEach(function(_arg) {
      var k, type;
      k = _arg[0], type = _arg[1];
      _this._nodeOrder.push(k);
      _this.prototype.__defineGetter__(k, function() {
        var _base;
        return (_base = this._private)[k] || (_base[k] = new type);
      });
      return _this.prototype.__defineSetter__(k, function(v) {
        return this._private[k] = v;
      });
    });
  };

  Statement.unmarshal = function(data, recur) {
    var it;
    it = new this;
    delete data._type;
    it._private = recur(data);
    return it;
  };

  function Statement(opts) {
    this._private = {};
    if (opts) {
      this.initialize(opts);
    }
  }

  Statement.prototype.initialize = function(opts) {
    return this.initialize = null;
  };

  Statement.prototype.compile = function(dialect) {
    var k, node, parts;
    parts = (function() {
      var _k, _len2, _ref2, _results;
      _ref2 = this.constructor._nodeOrder;
      _results = [];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        k = _ref2[_k];
        if (node = this._private[k]) {
          _results.push(dialect.compile(node));
        }
      }
      return _results;
    }).call(this);
    if (parts.length) {
      return this.constructor.prefix + parts.join(' ');
    } else {
      return "";
    }
  };

  Statement.prototype.toJSON = function() {
    var k, parent, v, _ref2;
    parent = Statement.__super__.toJSON.apply(this, arguments);
    _ref2 = this._private;
    for (k in _ref2) {
      v = _ref2[k];
      parent[k] = v.toJSON();
    }
    return parent;
  };

  return Statement;

})(Node);

ParenthesizedNodeSet = (function(_super) {

  __extends(ParenthesizedNodeSet, _super);

  function ParenthesizedNodeSet() {
    return ParenthesizedNodeSet.__super__.constructor.apply(this, arguments);
  }

  /* A NodeSet wrapped in parenthesis.
  */


  ParenthesizedNodeSet.prototype.compile = function() {
    return "(" + ParenthesizedNodeSet.__super__.compile.apply(this, arguments) + ")";
  };

  return ParenthesizedNodeSet;

})(NodeSet);

AbstractAlias = (function(_super) {

  __extends(AbstractAlias, _super);

  AbstractAlias.patch = function(klazz) {
    klazz.Alias = this;
    return klazz.prototype.as = function(name) {
      return new this.constructor.Alias(this, name);
    };
  };

  AbstractAlias.unmarshal = function(data, recur) {
    return new this(recur(data.obj), data.alias);
  };

  function AbstractAlias(obj, alias) {
    this.obj = obj;
    this.alias = alias;
  }

  AbstractAlias.prototype.ref = function() {
    return this.alias;
  };

  AbstractAlias.prototype.parens = true;

  AbstractAlias.prototype.compile = function(dialect, parents) {
    var left;
    if (this.shouldRenderFull(parents)) {
      left = dialect.compile(this.obj);
      if (this.parens) {
        left = dialect.maybeParens(left);
      }
      return left + " AS " + dialect.quote(this.alias);
    } else {
      return dialect.quote(this.alias);
    }
  };

  AbstractAlias.prototype.toJSON = function() {
    return merge(AbstractAlias.__super__.toJSON.apply(this, arguments), {
      obj: this.obj.toJSON(),
      alias: this.alias
    });
  };

  AbstractAlias.prototype.shouldRenderFull = function(parents) {
    return true;
  };

  return AbstractAlias;

})(Node);

TextNode = (function(_super) {
  var paramRegexp;

  __extends(TextNode, _super);

  TextNode.unmarshal = function(data, recur) {
    return new this(data.text, data.bindVals);
  };

  function TextNode(text, bindVals) {
    this.text = text;
    this.bindVals = bindVals != null ? bindVals : [];
  }

  paramRegexp = /\$([\w]+)\b/g;

  TextNode.prototype.compile = function(dialect) {
    var _this = this;
    return this.text.replace(paramRegexp, function(_, name) {
      if (name in _this.bindVals) {
        return dialect.parameter(_this.bindVals[name]);
      } else {
        throw new Error("Parameter " + name + " not present in " + (JSON.stringify(_this.bindVals)));
      }
    });
  };

  TextNode.prototype.toJSON = function() {
    return merge(TextNode.__super__.toJSON.apply(this, arguments), {
      text: this.text,
      bindVals: this.bindVals
    });
  };

  return TextNode;

})(Node);

TextAlias = (function(_super) {

  __extends(TextAlias, _super);

  function TextAlias() {
    return TextAlias.__super__.constructor.apply(this, arguments);
  }

  TextAlias.patch(TextNode);

  return TextAlias;

})(AbstractAlias);

SqlFunction = (function(_super) {

  __extends(SqlFunction, _super);

  /* Includes :class:`nodes::ComparableMixin`
  */


  SqlFunction.unmarshal = function(data, recur) {
    return new this(data.name, data.arglist);
  };

  function SqlFunction(name, arglist) {
    this.name = name;
    this.arglist = arglist;
  }

  SqlFunction.prototype.ref = function() {
    return this.name;
  };

  SqlFunction.prototype.compile = function(d) {
    return "" + this.name + (d.compile(this.arglist));
  };

  SqlFunction.prototype.toJSON = function() {
    return merge(SqlFunction.__super__.toJSON.apply(this, arguments), {
      name: this.name,
      arglist: this.arglist
    });
  };

  return SqlFunction;

})(Node);

FunctionAlias = (function(_super) {

  __extends(FunctionAlias, _super);

  function FunctionAlias() {
    return FunctionAlias.__super__.constructor.apply(this, arguments);
  }

  FunctionAlias.patch(SqlFunction);

  FunctionAlias.prototype.parens = false;

  FunctionAlias.prototype.shouldRenderFull = function(parents) {
    if (parents.some(function(it) {
      return it instanceof Column;
    })) {
      return false;
    }
    return parents.some(function(node) {
      return node instanceof ColumnSet || node instanceof RelationSet;
    });
  };

  return FunctionAlias;

})(AbstractAlias);

Parameter = (function(_super) {

  __extends(Parameter, _super);

  function Parameter() {
    return Parameter.__super__.constructor.apply(this, arguments);
  }

  /*
    Like a ValueNode, but will render as a bound parameter place-holder
    (e.g. ``$1``) and it's value will be collected by the dialect when compiling.
  */


  Parameter.prototype.compile = function(dialect) {
    return dialect.parameter(this.value);
  };

  return Parameter;

})(ValueNode);

Relation = (function(_super) {

  __extends(Relation, _super);

  function Relation() {
    return Relation.__super__.constructor.apply(this, arguments);
  }

  /*
    A relation node represents a table name or alias in a statement.
  */


  Relation.prototype.ref = function() {
    /*
        Return the table name. Aliased tables return the alias name.
    */
    return this.value;
  };

  Relation.prototype.project = function(field) {
    /* Return a new :class:`nodes::Column` of `field` from this table.
    */
    return new Column(this, toField(field));
  };

  return Relation;

})(Identifier);

RelationAlias = (function(_super) {

  __extends(RelationAlias, _super);

  /* An aliased :class:`nodes::Relation`
  */


  function RelationAlias() {
    return RelationAlias.__super__.constructor.apply(this, arguments);
  }

  RelationAlias.patch(Relation);

  RelationAlias.prototype.project = function(field) {
    return Relation.prototype.project.call(this, field);
  };

  RelationAlias.prototype.shouldRenderFull = function(parents) {
    return !parents.some(function(n) {
      return n instanceof Column;
    });
  };

  return RelationAlias;

})(AbstractAlias);

Field = (function(_super) {

  __extends(Field, _super);

  /* A column name
  */


  function Field() {
    return Field.__super__.constructor.apply(this, arguments);
  }

  return Field;

})(Identifier);

Column = (function(_super) {

  __extends(Column, _super);

  /*
    Includes :class:`nodes::ComparableMixin`
  */


  Column.unmarshal = function(data, recur) {
    return new this(recur(data.nodes[0]), recur(data.nodes[1]));
  };

  function Column(source, field) {
    this.source = source;
    this.field = field;
    Column.__super__.constructor.call(this, [this.source, this.field], '.');
  }

  Column.prototype.rel = function() {
    return this.source;
  };

  Column.prototype.as = function(alias) {
    /* Return an aliased version of this column.
    */
    return new Alias(this, alias);
  };

  return Column;

})(FixedNodeSet);

ColumnAlias = (function(_super) {

  __extends(ColumnAlias, _super);

  /* An aliased :class:`nodes::Column`
  */


  function ColumnAlias() {
    return ColumnAlias.__super__.constructor.apply(this, arguments);
  }

  ColumnAlias.patch(Column);

  ColumnAlias.prototype.rel = function() {
    return this.obj.rel();
  };

  ColumnAlias.prototype.parens = false;

  ColumnAlias.prototype.shouldRenderFull = function(parents) {
    return parents.some(function(node) {
      return node instanceof ColumnSet;
    });
  };

  return ColumnAlias;

})(AbstractAlias);

Limit = (function(_super) {

  __extends(Limit, _super);

  function Limit() {
    return Limit.__super__.constructor.apply(this, arguments);
  }

  Limit.prototype.compile = function() {
    if (this.value) {
      return "LIMIT " + this.value;
    } else {
      return "";
    }
  };

  return Limit;

})(IntegerNode);

Offset = (function(_super) {

  __extends(Offset, _super);

  function Offset() {
    return Offset.__super__.constructor.apply(this, arguments);
  }

  Offset.prototype.compile = function() {
    if (this.value) {
      return "OFFSET " + this.value;
    } else {
      return "";
    }
  };

  return Offset;

})(IntegerNode);

Binary = (function(_super) {

  __extends(Binary, _super);

  Binary.unmarshal = function(data, recur) {
    return new this(recur(data.left), recur(data.op), recur(data.right));
  };

  function Binary(left, op, right) {
    this.left = left;
    this.op = op;
    this.right = right;
    Binary.__super__.constructor.call(this, [this.left, this.op, this.right], ' ');
  }

  Binary.prototype.and = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new And([this].concat(__slice.call(args)));
  };

  Binary.prototype.or = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new Or([this].concat(__slice.call(args)));
  };

  Binary.prototype.compile = function(dialect) {
    return [dialect.compile(this.left), dialect.operator(this.op), dialect.compile(this.right)].join(' ');
  };

  Binary.prototype.toJSON = function() {
    return merge(Node.prototype.toJSON.call(this), {
      left: this.left.toJSON(),
      op: this.op,
      right: this.right.toJSON()
    });
  };

  return Binary;

})(FixedNodeSet);

Tuple = (function(_super) {

  __extends(Tuple, _super);

  function Tuple() {
    return Tuple.__super__.constructor.apply(this, arguments);
  }

  Tuple.prototype.glue = ', ';

  return Tuple;

})(ParenthesizedNodeSet);

ColumnSet = (function(_super) {

  __extends(ColumnSet, _super);

  function ColumnSet() {
    return ColumnSet.__super__.constructor.apply(this, arguments);
  }

  /* The list of projected columns in a query
  */


  ColumnSet.prototype.glue = ', ';

  return ColumnSet;

})(NodeSet);

Returning = (function(_super) {

  __extends(Returning, _super);

  function Returning() {
    return Returning.__super__.constructor.apply(this, arguments);
  }

  Returning.extend = function(klazz) {
    return klazz.prototype.addReturning = function(cols) {
      var col, _k, _len2;
      for (_k = 0, _len2 = cols.length; _k < _len2; _k++) {
        col = cols[_k];
        this.returning.addNode(toField(col));
      }
      return null;
    };
  };

  Returning.prototype.compile = function() {
    var string;
    if (string = Returning.__super__.compile.apply(this, arguments)) {
      return "RETURNING " + string;
    } else {
      return "";
    }
  };

  return Returning;

})(ColumnSet);

Distinct = (function(_super) {

  __extends(Distinct, _super);

  function Distinct(enable) {
    this.enable = enable != null ? enable : false;
    Distinct.__super__.constructor.apply(this, arguments);
  }

  Distinct.prototype.compile = function(dialect) {
    if (!this.enable) {
      return '';
    } else if (this.nodes.length) {
      return "DISTINCT(" + Distinct.__super__.compile.apply(this, arguments) + ")";
    } else {
      return 'DISTINCT';
    }
  };

  return Distinct;

})(ColumnSet);

SelectColumnSet = (function(_super) {

  __extends(SelectColumnSet, _super);

  function SelectColumnSet() {
    return SelectColumnSet.__super__.constructor.apply(this, arguments);
  }

  SelectColumnSet.prototype.prune = function(predicate) {
    /*
        Recurse over child nodes, removing all Column nodes that match the
        predicate.
    */
    return this.nodes = this.nodes.filter(function(n) {
      return !predicate(n);
    });
  };

  SelectColumnSet.prototype.compile = function(dialect) {
    if (!this.nodes.length) {
      return '*';
    } else {
      return SelectColumnSet.__super__.compile.apply(this, arguments);
    }
  };

  return SelectColumnSet;

})(ColumnSet);

RelationSet = (function(_super) {

  __extends(RelationSet, _super);

  function RelationSet() {
    return RelationSet.__super__.constructor.apply(this, arguments);
  }

  /*
    Manages a set of relations and exposes methods to find them by alias.
  */


  RelationSet.prototype.addNode = function(node) {
    if (!this.first) {
      this.relsByName = {};
      this.nodes.push(node);
      return this.first = this.active = this.relsByName[node.ref()] = node;
    } else {
      RelationSet.__super__.addNode.apply(this, arguments);
      return this.active = this.relsByName[node.ref()] = node.relation;
    }
  };

  RelationSet.prototype.get = function(name, strict) {
    var found;
    if (strict == null) {
      strict = true;
    }
    if ('string' !== typeof name) {
      name = name.ref();
    }
    found = this.relsByName[name];
    if (strict && !found) {
      throw new Error("No such relation " + name + " in " + (Object.keys(this.relsByName)));
    }
    return found;
  };

  RelationSet.prototype["switch"] = function(name) {
    return this.active = this.get(name);
  };

  RelationSet.prototype.compile = function(dialect) {
    var string;
    if (string = RelationSet.__super__.compile.apply(this, arguments)) {
      return "FROM " + string;
    } else {
      return "";
    }
  };

  return RelationSet;

})(NodeSet);

Join = (function(_super) {
  var JOIN, ON;

  __extends(Join, _super);

  JOIN = new ValueNode('JOIN');

  ON = new ValueNode('ON');

  Join.unmarshal = function(data, recur) {
    var clause, join, nodes, _k, _len2, _ref2;
    nodes = data.nodes;
    join = new this(recur(nodes[0]), recur(nodes[2]));
    _ref2 = nodes.slice(4);
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      clause = _ref2[_k];
      join.on(recur(clause));
    }
    return join;
  };

  function Join(type, relation) {
    var nodes;
    this.type = type;
    this.relation = relation;
    nodes = [this.type, JOIN, this.relation];
    Join.__super__.constructor.call(this, nodes);
  }

  Join.prototype.on = function(clause) {
    if (this.nodes.length < 4) {
      this.nodes.push(ON);
    }
    return this.nodes.push(clause);
  };

  Join.prototype.ref = function() {
    return this.relation.ref();
  };

  return Join;

})(FixedNodeSet);

Where = (function(_super) {

  __extends(Where, _super);

  function Where() {
    return Where.__super__.constructor.apply(this, arguments);
  }

  Where.prototype.glue = ' AND ';

  Where.prototype.compile = function(dialect) {
    var string;
    if (string = Where.__super__.compile.apply(this, arguments)) {
      return "WHERE " + string;
    } else {
      return "";
    }
  };

  return Where;

})(NodeSet);

Or = (function(_super) {

  __extends(Or, _super);

  function Or() {
    return Or.__super__.constructor.apply(this, arguments);
  }

  Or.prototype.glue = ' OR ';

  Or.prototype.and = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new And([this].concat(__slice.call(args)));
  };

  Or.prototype.or = function() {
    var arg, args, ret, _k, _len2;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    ret = this.copy();
    for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
      arg = args[_k];
      ret.addNode(arg);
    }
    return ret;
  };

  return Or;

})(ParenthesizedNodeSet);

And = (function(_super) {

  __extends(And, _super);

  function And() {
    return And.__super__.constructor.apply(this, arguments);
  }

  And.prototype.glue = ' AND ';

  And.prototype.and = function() {
    var arg, args, ret, _k, _len2;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    ret = this.copy();
    for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
      arg = args[_k];
      ret.addNode(arg);
    }
    return ret;
  };

  And.prototype.or = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new Or([this].concat(__slice.call(args)));
  };

  return And;

})(ParenthesizedNodeSet);

GroupBy = (function(_super) {

  __extends(GroupBy, _super);

  function GroupBy() {
    return GroupBy.__super__.constructor.apply(this, arguments);
  }

  GroupBy.prototype.glue = ', ';

  GroupBy.prototype.compile = function(dialect) {
    var string;
    if (string = GroupBy.__super__.compile.apply(this, arguments)) {
      return "GROUP BY " + string;
    } else {
      return "";
    }
  };

  return GroupBy;

})(NodeSet);

Having = (function(_super) {

  __extends(Having, _super);

  function Having() {
    return Having.__super__.constructor.apply(this, arguments);
  }

  Having.prototype.glue = ' AND ';

  Having.prototype.compile = function(dialect) {
    var string;
    if (string = Having.__super__.compile.apply(this, arguments)) {
      return "HAVING " + string;
    } else {
      return "";
    }
  };

  return Having;

})(NodeSet);

OrderBy = (function(_super) {

  __extends(OrderBy, _super);

  function OrderBy(orderings) {
    OrderBy.__super__.constructor.call(this, orderings, ', ');
  }

  OrderBy.prototype.compile = function(dialect) {
    var string;
    if (string = OrderBy.__super__.compile.apply(this, arguments)) {
      return "ORDER BY " + string;
    } else {
      return "";
    }
  };

  return OrderBy;

})(NodeSet);

Ordering = (function(_super) {

  __extends(Ordering, _super);

  function Ordering(projection, direction) {
    if (typeof direction === 'string') {
      direction = new ValueNode(direction);
    }
    Ordering.__super__.constructor.call(this, [projection, direction]);
  }

  return Ordering;

})(FixedNodeSet);

SubQuery = (function(_super) {

  __extends(SubQuery, _super);

  function SubQuery(statement) {
    this.statement = statement;
    if (!(this.statement instanceof Statement)) {
      throw new Error("" + this.statement + " is not a Statement");
    }
  }

  SubQuery.prototype.compile = function(dialect) {
    return this.statement.compile(dialect);
  };

  SubQuery.prototype.toJSON = function() {
    return {
      _type: this.constructor.name,
      statement: this.statement
    };
  };

  SubQuery.prototype.copy = function() {
    return unmarshal(this.toJSON());
  };

  return SubQuery;

})(Node);

SubQueryAlias = (function(_super) {

  __extends(SubQueryAlias, _super);

  function SubQueryAlias() {
    return SubQueryAlias.__super__.constructor.apply(this, arguments);
  }

  SubQueryAlias.patch(SubQuery);

  SubQueryAlias.prototype.shouldRenderFull = function(parents) {
    return !parents.slice(0, -1).some(function(node) {
      return node instanceof AbstractAlias || node instanceof Binary;
    });
  };

  return SubQueryAlias;

})(AbstractAlias);

Select = (function(_super) {

  __extends(Select, _super);

  /*
    The root node of a SELECT query
  */


  function Select() {
    return Select.__super__.constructor.apply(this, arguments);
  }

  Select.prefix = 'SELECT ';

  Select.structure([['distinct', Distinct], ['projections', SelectColumnSet], ['relations', RelationSet], ['where', Where], ['groupBy', GroupBy], ['having', Having], ['orderBy', OrderBy], ['limit', Limit], ['offset', Offset]]);

  Select.prototype.initialize = function(opts) {
    this.projections;
    if (opts.table) {
      return this.relations.addNode(toRelation(opts.table));
    }
  };

  return Select;

})(Statement);

Update = (function(_super) {
  var UpdateSet;

  __extends(Update, _super);

  /*
    The root node of an UPDATE query
  */


  function Update() {
    return Update.__super__.constructor.apply(this, arguments);
  }

  Update.UpdateSet = UpdateSet = (function(_super1) {

    __extends(UpdateSet, _super1);

    function UpdateSet(nodes) {
      UpdateSet.__super__.constructor.call(this, nodes, ', ');
    }

    UpdateSet.prototype.compile = function(dialect) {
      var string;
      if (string = UpdateSet.__super__.compile.apply(this, arguments)) {
        return "SET " + string;
      } else {
        return "";
      }
    };

    return UpdateSet;

  })(NodeSet);

  Update.prefix = 'UPDATE ';

  Update.structure([['relation', Relation], ['updates', UpdateSet], ['orderBy', OrderBy], ['limit', Limit], ['fromList', RelationSet], ['where', Where], ['returning', Returning]]);

  Returning.extend(Update);

  Update.prototype.initialize = function(opts) {
    return this.relation = toRelation(opts.table);
  };

  return Update;

})(Statement);

Insert = (function(_super) {
  var ColumnList, InsertData, valOrDefault;

  __extends(Insert, _super);

  /*
    The root node of an INSERT query
  */


  function Insert() {
    return Insert.__super__.constructor.apply(this, arguments);
  }

  Insert.InsertData = InsertData = (function(_super1) {

    __extends(InsertData, _super1);

    function InsertData() {
      return InsertData.__super__.constructor.apply(this, arguments);
    }

    InsertData.prototype.glue = ', ';

    InsertData.prototype.compile = function(dialect) {
      var string;
      if (string = InsertData.__super__.compile.apply(this, arguments)) {
        return "VALUES " + string;
      } else {
        return "";
      }
    };

    return InsertData;

  })(NodeSet);

  Insert.ColumnList = ColumnList = (function(_super1) {

    __extends(ColumnList, _super1);

    function ColumnList() {
      return ColumnList.__super__.constructor.apply(this, arguments);
    }

    return ColumnList;

  })(Tuple);

  Insert.prefix = 'INSERT INTO ';

  Insert.structure([['relation', Relation], ['columns', ColumnList], ['data', InsertData], ['returning', Returning]]);

  Returning.extend(Insert);

  Insert.prototype.initialize = function(opts) {
    var _ref2;
    if (!((_ref2 = opts.fields) != null ? _ref2.length : void 0)) {
      throw new Error("Column list is required when constructing an INSERT");
    }
    this.columns = new ColumnList(opts.fields.map(toField));
    return this.relation = toRelation(opts.table);
  };

  Insert.prototype.addRow = function(row) {
    if (this.data instanceof Select) {
      throw new Error("Cannot add rows when inserting from a SELECT");
    }
    if (Array.isArray(row)) {
      return this.addRowArray(row);
    } else {
      return this.addRowObject(row);
    }
  };

  Insert.prototype.addRowArray = function(row) {
    var count, message, params, v;
    if (!(count = this.columns.nodes.length)) {
      throw new Error("Must set column list before inserting arrays");
    }
    if (row.length !== count) {
      message = "Wrong number of values in array, expected " + this.columns.nodes;
      throw new Error(message);
    }
    params = (function() {
      var _k, _len2, _results;
      _results = [];
      for (_k = 0, _len2 = row.length; _k < _len2; _k++) {
        v = row[_k];
        if (v instanceof Node) {
          _results.push(v);
        } else {
          _results.push(new Parameter(v));
        }
      }
      return _results;
    })();
    return this.data.addNode(new Tuple(params));
  };

  Insert.prototype.addRowObject = function(row) {
    /*
        Add a row from an object. This will set the column list of the query if it
        isn't set yet. If it `is` set, then only keys matching the existing column
        list will be inserted.
    */
    return this.addRowArray(this.columns.nodes.map(valOrDefault.bind(row)));
  };

  valOrDefault = function(field) {
    var key;
    key = field.value;
    if (this.hasOwnProperty(key)) {
      return this[key];
    } else {
      return CONST_NODES.DEFAULT;
    }
  };

  Insert.prototype.from = function(query) {
    if (!(query instanceof Select)) {
      throw new Error("Can only insert from a SELECT");
    }
    return this.data = query;
  };

  return Insert;

})(Statement);

Delete = (function(_super) {

  __extends(Delete, _super);

  /*
    The root node of a DELETE query
  */


  function Delete() {
    return Delete.__super__.constructor.apply(this, arguments);
  }

  Delete.prefix = 'DELETE ';

  Delete.structure([['relations', RelationSet], ['where', Where], ['orderBy', OrderBy], ['limit', Limit], ['returning', Returning]]);

  Returning.extend(Delete);

  Delete.prototype.initialize = function(opts) {
    return this.relations.addNode(toRelation(opts.table));
  };

  return Delete;

})(Statement);

ComparableMixin = (function() {
  /*
    A mixin that adds comparison methods to a class. Each of these comparison
    methods will yield a new AST node comparing the invocant to the argument.
  */

  function ComparableMixin() {}

  ComparableMixin.patch = function(klazz) {
    var k, v, _ref2, _results;
    _ref2 = this.prototype;
    _results = [];
    for (k in _ref2) {
      v = _ref2[k];
      _results.push(klazz.prototype[k] = v);
    }
    return _results;
  };

  ComparableMixin.prototype.eq = function(other) {
    /* ``this = other``
    */
    return this.compare('=', other);
  };

  ComparableMixin.prototype.ne = function(other) {
    /* ``this != other``
    */
    return this.compare('!=', other);
  };

  ComparableMixin.prototype.gt = function(other) {
    /* ``this > other``
    */
    return this.compare('>', other);
  };

  ComparableMixin.prototype.lt = function(other) {
    /* ``this < other``
    */
    return this.compare('<', other);
  };

  ComparableMixin.prototype.lte = function(other) {
    /* ``this <= other``
    */
    return this.compare('<=', other);
  };

  ComparableMixin.prototype.gte = function(other) {
    /* ``this >= other``
    */
    return this.compare('>=', other);
  };

  ComparableMixin.prototype.like = function(other) {
    return this.compare('LIKE', other);
  };

  ComparableMixin.prototype.is = function(other) {
    return this.compare('IS', other != null ? other : CONST_NODES.NULL);
  };

  ComparableMixin.prototype.isNot = function(other) {
    return this.compare('IS NOT', other != null ? other : CONST_NODES.NULL);
  };

  ComparableMixin.prototype["in"] = function(other) {
    return this.compare('IN', other);
  };

  ComparableMixin.prototype.notIn = function(other) {
    return this.compare('NOT IN', other);
  };

  ComparableMixin.prototype.compare = function(op, other) {
    /* ``this op other`` **DANGER** `op` is **NOT** escaped!
    */
    return new Binary(this, op, toParam(other));
  };

  return ComparableMixin;

})();

_ref2 = [TextNode, SqlFunction, SqlFunction.Alias, Column, Column.Alias, Tuple];
for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
  ctor = _ref2[_k];
  ComparableMixin.patch(ctor);
}

toParam = function(it) {
  /*
    Return a Node that can be used as a parameter.
  
      * :class:`queries/select::SelectQuery` instances will be treated as
        un-named sub queries,
      * Node instances will be returned unchanged.
      * Arrays will be turned into a :class:`nodes::Tuple` instance.
  
    All other types will be wrapped in a :class:`nodes::Parameter` instance.
  */

  var SelectQuery;
  SelectQuery = require('./queries/select');
  if ((it != null ? it.constructor : void 0) === SelectQuery) {
    return new Tuple([it.q]);
  } else if (it instanceof Node) {
    return it;
  } else if (Array.isArray(it)) {
    return new Tuple(it.map(toParam));
  } else {
    return new Parameter(it);
  }
};

toRelation = function(it) {
  /*
    Transform ``it`` into a :class:`nodes::Relation` instance.
  
    This accepts `strings, ``Relation`` and ``Alias`` instances, and objects with
    a single key-value pair, which will be turned into an ``Alias`` instance.
  
    Examples::
  
       toRelation('table1')     == new Relation('table1')
       toRelation(t1: 'table1') == new Alias(new Relation('table1'), 't1')
  
    **Throws Errors** if the input is not valid.
  */

  var alias;
  switch (it.constructor) {
    case Relation:
    case Relation.Alias:
    case SqlFunction:
    case SqlFunction.Alias:
    case SubQuery.Alias:
      return it;
    case String:
      return new Relation(it);
    case Object:
      if (alias = getAlias(it)) {
        return toRelation(it[alias]).as(alias);
      } else {
        throw new Error("Can't make relation out of " + it);
      }
      break;
    default:
      throw new Error("Can't make relation out of " + it);
  }
};

toField = function(it) {
  if (typeof it === 'string') {
    return new Field(it);
  } else if (it instanceof Field) {
    return it;
  } else {
    throw new Error("Can't make a field out of " + it);
  }
};

toColumn = function(relation, field) {
  /*
    Create a new :class:`nodes::Column` instance.
  
    The first argument is optional and specifies a table (or alias) name.
    Alternatively, you can specify the relation name and field with a single
    dot-separated string::
  
      toColumn('departments.name') == toColumn('departments', 'name')
  
    Either argument can be an pre-constructed node object (of the correct type).
  */

  var parts;
  if (field != null) {
    return new Column(toRelation(relation), toField(field));
  } else if (typeof relation === 'string') {
    parts = relation.split('.');
    if (parts.length === 2) {
      return new Column(toRelation(parts[0]), toField(parts[1]));
    }
  }
  throw new Error("Can't make projection from object: " + relation);
};

toProjection = toColumn;

sqlFunction = function(name, args) {
  /*
    Create a new SQL function call node. For example::
  
        count = g.sqlFunction('count', [g.text('*')])
  */
  args = args.map(toParam);
  if (args.length === 1 && args[0] instanceof Tuple && args[0].nodes.length === 1) {
    args = args[0];
  } else {
    args = new Tuple(args);
  }
  return new SqlFunction(name, args);
};

func = function(name) {
  /*
    Create a factory for calling the given SQL function. Example::
  
      count = g.func('count')
      count(g.text('*'))
  
    The returned factory accepts any number of parameters::
  
      substringIndex = g.func('SUBSTRING_INDEX')
      substringIndex(g.text('mycol'), '-', 1)  # SUBSTRING_INDEX(mycol, '-', 1)
  */
  return function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return sqlFunction(name, args);
  };
};

getAlias = function(o) {
  /*
    Check if ``o`` is an object literal representing an alias, and return the
    alias name if it is.
  */

  var keys;
  if ('object' === typeof o) {
    keys = Object.keys(o);
    if (keys.length === 1) {
      return keys[0];
    }
  }
  return null;
};

text = function(rawSQL, bindVals) {
  /*
    Construct a node with a raw SQL string and (optionally) parameters. Useful for
    when you want to construct a query that is difficult or impossible with the
    normal APIs. [#]_
  
    To use bound parameters in the SQL string, use ``$`` prefixed names, and
    pass a ``bindVals`` argument with corresponding property names. For example,
    :meth:`~queries/sud::SUDQuery.where` doesn't (currently) support the SQL
    ``BETWEEN`` operator, but if you needed it, you could use ``text``::
  
        function peopleInWeightRange (min, max, callback) {
          return select('people')
            .where(text("weight BETWEEN $min AND $max", {min: min, max: max}))
            .execute(callback)
        }
  
    Because javascript doesn't distinguish between array indexing and property
    access, it can be more clear to use numbered parameters for such short
    snippets::
  
        function peopleInWeightRange (min, max, callback) {
          return select('people')
            .where(text("weight BETWEEN $0 AND $1", [min, max]))
            .execute(callback)
        }
  
    .. [#] If you find yourself using this function often, please `open an issue`_
      on Github with details on your use case so `gesundheit` can support it
      more elegantly.
  
    ..  _open an issue: https://github.com/BetSmartMedia/gesundheit/issues/new?title=I%20use%20text()%20for%20blah
  */
  return new TextNode(rawSQL, bindVals);
};

binaryOp = function(left, op, right) {
  /*
    Create a new :class:`nodes::Binary` node::
  
      binaryOp('hstore_column', '->', toParam(y))
      # hstore_column -> ?
  
    This is for special cases, normally you want to use the methods from
    :class:`nodes::ComparableMixin`.
  */
  return new Binary(left, op, right);
};

Prefixed = (function(_super) {

  __extends(Prefixed, _super);

  function Prefixed(prefix, node) {
    this.prefix = prefix;
    this.node = node;
  }

  Prefixed.prototype.compile = function() {
    return this.prefix + this.node.compile.apply(this.node, arguments);
  };

  return Prefixed;

})(ValueNode);

PrefixedAlias = (function(_super) {

  __extends(PrefixedAlias, _super);

  function PrefixedAlias() {
    return PrefixedAlias.__super__.constructor.apply(this, arguments);
  }

  PrefixedAlias.patch(Prefixed);

  return PrefixedAlias;

})(AbstractAlias);

exists = function(subquery) {
  /* Create an ``EXISTS (<subquery>)`` node for `where`
  */
  return new Prefixed('EXISTS ', new Tuple([subquery.q || subquery]));
};

notExists = function(subquery) {
  /* Create a ``NOT EXISTS (<subquery>)`` node for `where`
  */
  return new Prefixed('NOT EXISTS ', new Tuple([subquery.q || subquery]));
};

tuple = function(input) {
  /*
    Create a new Tuple from an array of nodes. Any item in the array that is
    **not** an `instanceof Node` will be turned into a parameter with
    :func:`nodes::toParam`.
  */
  return new Tuple(input.map(toParam));
};

module.exports = {
  CONST_NODES: CONST_NODES,
  JOIN_TYPES: JOIN_TYPES,
  binaryOp: binaryOp,
  exists: exists,
  func: func,
  getAlias: getAlias,
  notExists: notExists,
  sqlFunction: sqlFunction,
  text: text,
  toField: toField,
  toParam: toParam,
  toColumn: toColumn,
  toProjection: toProjection,
  toRelation: toRelation,
  tuple: tuple,
  Node: Node,
  ValueNode: ValueNode,
  IntegerNode: IntegerNode,
  Identifier: Identifier,
  JoinType: JoinType,
  NodeSet: NodeSet,
  FixedNodeSet: FixedNodeSet,
  Statement: Statement,
  ParenthesizedNodeSet: ParenthesizedNodeSet,
  TextNode: TextNode,
  TextAlias: TextAlias,
  SqlFunction: SqlFunction,
  FunctionAlias: FunctionAlias,
  Parameter: Parameter,
  Relation: Relation,
  RelationAlias: Relation.Alias,
  Field: Field,
  Column: Column,
  ColumnAlias: Column.Alias,
  Limit: Limit,
  Offset: Offset,
  Binary: Binary,
  Tuple: Tuple,
  ColumnSet: ColumnSet,
  Returning: Returning,
  Distinct: Distinct,
  SelectColumnSet: SelectColumnSet,
  RelationSet: RelationSet,
  Join: Join,
  Where: Where,
  Or: Or,
  And: And,
  GroupBy: GroupBy,
  OrderBy: OrderBy,
  Ordering: Ordering,
  SubQuery: SubQuery,
  Select: Select,
  Update: Update,
  UpdateSet: Update.UpdateSet,
  Insert: Insert,
  ColumnList: Insert.ColumnList,
  InsertData: Insert.InsertData,
  Delete: Delete,
  ComparableMixin: ComparableMixin
};

unmarshal = require('./unmarshal')();

copy = function(it) {
  var c, k, v;
  if (!it) {
    return it;
  }
  switch (it.constructor) {
    case String:
    case Number:
    case Boolean:
      return it;
    case Array:
      return it.map(copy);
    case Object:
      c = {};
      for (k in it) {
        v = it[k];
        c[k] = copy(v);
      }
      return c;
    default:
      if (it.copy != null) {
        return it.copy();
      } else {
        throw new Error("Don't know how to copy " + it);
      }
  }
};

merge = function(dest, src) {
  var k, v;
  for (k in src) {
    v = src[k];
    dest[k] = v;
  }
  return dest;
};

},{"./queries/select":13,"./unmarshal":16}],8:[function(require,module,exports){
var process=require("__browserify_process");// Generated by CoffeeScript 1.4.0
var BaseQuery, EventEmitter, assert, fluid, inspect, method, nodes, _i, _len, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

inspect = require('util').inspect;

EventEmitter = require('events').EventEmitter;

assert = require('assert');

nodes = require('../nodes');

module.exports = BaseQuery = (function(_super) {

  __extends(BaseQuery, _super);

  /*
    The base class for all queries. While this class itself is not part of
    gesundheits public API, the methods defined on it are.
  */


  BaseQuery.rootNode = null;

  BaseQuery.unmarshal = function(data, recur) {
    var query;
    query = new this;
    query.q = recur(data.q);
    return query;
  };

  function BaseQuery(engine, opts) {
    if (opts == null) {
      opts = {};
    }
    /*
        :param engine: The engine the query will be bound to.
    
        :param opts.table:
          Any object that can be converted by :func:`nodes::toRelation`.
    */

    this.bind(engine);
    this.q = opts.rootNode || new this.constructor.rootNode(opts);
  }

  BaseQuery.prototype.copy = function(fn) {
    /* Instantiate a new query with a deep copy of this ones AST
    */

    var query;
    query = new this.constructor(this.engine, {
      rootNode: this.q.copy()
    });
    if (fn) {
      return query.visit(fn);
    } else {
      return query;
    }
  };

  BaseQuery.prototype.as = function(alias) {
    return new nodes.SubQuery(this.q).as(alias);
  };

  BaseQuery.prototype.visit = function(fn) {
    /*
        Call the given function in the context of this query. This is useful with
        query factory functions where you can use it as a sort-of-DSL::
    
            SELECT('people', ['name'], function(q) {
              // this === q
              this.join('addresses', {
                on: {person_id: q.project('people', 'id')},
                fields: ['city', 'region']
              })
            })
    */
    return fn.call(this, this);
  };

  BaseQuery.prototype.bind = function(engine) {
    /*
        Bind this query object to a new engine.
        If no argument is given the query will be bound to the default engine.
    */

    var oldEngine, _base, _ref, _ref1;
    oldEngine = this.engine;
    this.engine = engine || require('../index').defaultEngine;
    if (this.engine !== oldEngine) {
      if (oldEngine != null) {
        if (typeof oldEngine.unextendQuery === "function") {
          oldEngine.unextendQuery(this);
        }
      }
      if (typeof (_base = this.engine).extendQuery === "function") {
        _base.extendQuery(this);
      }
    }
    assert((_ref = this.engine) != null ? _ref.query : void 0, "Engine has no query method: " + (inspect(this.engine)));
    return assert((_ref1 = this.engine) != null ? _ref1.compile : void 0, "Engine has no compile method: " + (inspect(this.engine)));
  };

  BaseQuery.prototype.render = function() {
    /*
        Render the query to a SQL string.
    */
    return this.compile()[0];
  };

  BaseQuery.prototype.compile = function() {
    /*
        Compile this query object, returning a SQL string and parameter array.
    */
    return this.engine.compile(this.q);
  };

  BaseQuery.prototype.execute = function(cb) {
    /*
        Execute the query using ``@engine`` and return a `QueryAdapter`.
    
        :param cb: An (optional) node-style callback that will be called with any
          errors and/or the query results. If no callback is given, an `AnyDB Query`_
          will be returned.
    
        .. _AnyDB Query: https://github.com/grncdr/node-any-db/blob/master/DESIGN.md#query-adapters
    */

    var args, emitter;
    try {
      args = this.compile();
      args.push(cb);
    } catch (err) {
      emitter = new EventEmitter;
      process.nextTick(function() {
        if (cb) {
          return cb(err);
        } else {
          return emitter.emit('error', err);
        }
      });
      return emitter;
    }
    return this.engine.query.apply(this.engine, args);
  };

  BaseQuery.prototype.toString = function() {
    return this.render();
  };

  BaseQuery.prototype.toJSON = function() {
    return {
      _type: this.constructor.name,
      q: this.q.toJSON()
    };
  };

  return BaseQuery;

})(EventEmitter);

fluid = require('../decorators/fluid');

_ref = ['bind', 'visit'];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  method = _ref[_i];
  BaseQuery.prototype[method] = fluid(BaseQuery.prototype[method]);
}

},{"../decorators/fluid":2,"../index":6,"../nodes":7,"__browserify_process":33,"assert":23,"events":24,"util":28}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
var Delete, DeleteQuery, SUDQuery, returnable,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

SUDQuery = require('./sud');

returnable = require('./returnable');

Delete = require('../nodes').Delete;

module.exports = DeleteQuery = (function(_super) {

  __extends(DeleteQuery, _super);

  /* Delete queries only add a 'returning' method to ``SUDQuery``
  */


  function DeleteQuery() {
    return DeleteQuery.__super__.constructor.apply(this, arguments);
  }

  DeleteQuery.rootNode = Delete;

  returnable(DeleteQuery);

  return DeleteQuery;

})(SUDQuery);

},{"../nodes":7,"./returnable":12,"./sud":14}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
/*
The factory functions defined here create instances of the corresponding
`*Query` manager classes, which fit the following inheritance hierarchy:

  * BaseQuery

    * InsertQuery

    * SUDQuery

      * SelectQuery

      * UpdateQuery

      * DeleteQuery

.. _query-factories:

These functions are the same ones re-exported by the main gesundheit module
(where they bind queries to ``gesundheit.defaultEngine``), and attached to
engine/transaction objects (where they bind queries to the engine/transaction
they are called on).

Each one accepts a table name or alias object (anything handled by
:func:`nodes::toRelation`), one or more extra parameters, and an optional
visitor callback as a final parameter that will be called with it's ``this``
context set to the newly constructed query instance.
*/

var DELETE, DeleteQuery, INSERT, InsertQuery, SELECT, SelectQuery, UPDATE, UpdateQuery, maybeVisit;

InsertQuery = require('./insert');

SelectQuery = require('./select');

UpdateQuery = require('./update');

DeleteQuery = require('./delete');

INSERT = function(table, fieldsOrRow) {
  /*
    Create a new :class:`queries/insert::InsertQuery` that will add rows to
    ``table``.
  
    :param table: Name of the table that rows will be inserted into.
    :param fieldsOrRow: Either an array of column names that will be inserted, or a
      plain object representing a row of data to insert, in which case the keys
      of the object will define the columns that are inserted.
    :param visitor: (Optional) a function that will be called with it's context
      set to the newly constructed query object.
  
    .. warning::
      The column names passed in ``fields`` will be printed into the query
      **unescaped** so do **not** use arbitrary input here. This is hopefully only temporary.
  */

  var fields, iq, row;
  if (Array.isArray(fieldsOrRow)) {
    fields = fieldsOrRow;
  } else if (typeof fieldsOrRow === 'object') {
    row = fieldsOrRow;
    fields = Object.keys(row);
  }
  iq = new InsertQuery(this, {
    table: table,
    fields: fields
  });
  if (row) {
    iq.addRow(row);
  }
  return iq;
};

SELECT = function(table, fields) {
  /*
    Create a new :class:`queries/select::SelectQuery` selecting from ``table``.
  
    :param table: Name or alias object of the first table to select rows from.
      More tables can be joined using :meth:`queries/select::SelectQuery.join`.
    :param fields: (Optional) Fields to project from ``table``. If this is not
      given, all fields (``*``) will be projected until
      :meth:`queries/select::SelectQuery.fields` is called.
    :param visitor: (Optional) a function that will be called with it's context
      set to the newly constructed query object.
  */

  var query;
  query = new SelectQuery(this, {
    table: table
  });
  if (fields != null) {
    query.fields.apply(query, fields);
  }
  return query;
};

UPDATE = function(table) {
  /*
    Create a new :class:`queries/update::UpdateQuery` that will update ``table``.
  
    :param table: Name or alias of the table to update.
    :param visitor: (Optional) a function that will be called with it's context
      set to the newly constructed query object.
  */
  return new UpdateQuery(this, {
    table: table
  });
};

DELETE = function(table) {
  /*
    Create a new :class:`queries/delete::DeleteQuery` that will delete rows from
    ``table``.
  
    :param table: Name or alias of the table to delete rows from.
    :param visitor: (Optional) a function that will be called with it's context
      set to the newly constructed query object.
  */
  return new DeleteQuery(this, {
    table: table
  });
};

exports.mixinFactoryMethods = function(invocant, getEngine) {
  /*
    Add wrappers methods for each of the query factory functions to ``invocant``
    using lower, UPPER, and Camel cases. The new methods will retrieve an engine
    using ``getEngine`` and then create the query bound to that engine.
  
    If ``getEngine`` is not given, queries will be bound to ``invocant`` instead.
  */

  var factory, type, _fn, _ref;
  if (getEngine == null) {
    getEngine = function() {
      return invocant;
    };
  }
  _ref = {
    INSERT: INSERT,
    SELECT: SELECT,
    UPDATE: UPDATE,
    DELETE: DELETE
  };
  _fn = function(type, factory) {
    var wrapper;
    factory = maybeVisit(factory);
    wrapper = function() {
      return factory.apply(getEngine(), arguments);
    };
    invocant[type] = wrapper;
    invocant[type.toLowerCase()] = wrapper;
    return invocant[type[0] + type.toLowerCase().substring(1)] = wrapper;
  };
  for (type in _ref) {
    factory = _ref[type];
    _fn(type, factory);
  }
  return invocant;
};

maybeVisit = function(func) {
  return function() {
    var a, cb;
    a = [].slice.call(arguments);
    if (typeof a[a.length - 1] === 'function') {
      cb = a.pop();
      return func.apply(this, a).visit(cb);
    } else {
      return func.apply(this, a);
    }
  };
};

},{"./delete":9,"./insert":11,"./select":13,"./update":15}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
var BaseQuery, Insert, InsertQuery, SelectQuery, fluid, method, returnable, toField, _i, _len, _ref, _ref1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

returnable = require('./returnable');

BaseQuery = require('./base');

SelectQuery = require('./select');

_ref = require('../nodes'), Insert = _ref.Insert, toField = _ref.toField;

module.exports = InsertQuery = (function(_super) {

  __extends(InsertQuery, _super);

  /*
    Insert queries are much simpler than most query types: they cannot join
    multiple tables.
  */


  function InsertQuery() {
    return InsertQuery.__super__.constructor.apply(this, arguments);
  }

  InsertQuery.rootNode = Insert;

  returnable(InsertQuery);

  InsertQuery.prototype.addRows = function(rows, variadic) {
    /* Add multiple rows of data to the insert statement.
    */

    var row, _i, _len, _results;
    if (variadic != null) {
      console.warn("DEPRECATED: InsertQuery::addRows will not be variadic in a future release.", new Error().stack.split('\n').slice(1).join('\n'));
      rows = Array.prototype.slice.call(arguments);
    }
    _results = [];
    for (_i = 0, _len = rows.length; _i < _len; _i++) {
      row = rows[_i];
      _results.push(this.q.addRow(row));
    }
    return _results;
  };

  InsertQuery.prototype.addRow = function(row) {
    /* Add a single row
    */
    return this.q.addRow(row);
  };

  InsertQuery.prototype.from = function(query) {
    /* Insert from a select query.
    */
    return this.q.from(query.q || query);
  };

  return InsertQuery;

})(BaseQuery);

fluid = require('../decorators/fluid');

_ref1 = ['addRow', 'addRows', 'from', 'returning'];
for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
  method = _ref1[_i];
  InsertQuery.prototype[method] = fluid(InsertQuery.prototype[method]);
}

},{"../decorators/fluid":2,"../nodes":7,"./base":8,"./returnable":12,"./select":13}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
var fluid, variadic;

variadic = require('../decorators/variadic');

fluid = require('../decorators/fluid');

module.exports = function(klazz) {
  return klazz.prototype.returning = fluid(variadic(function(cols) {
    this.q.addReturning(cols);
    return this;
  }));
};

},{"../decorators/fluid":2,"../decorators/variadic":3}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
var And, JOIN_TYPES, Join, Node, SUDQuery, Select, SelectQuery, deprecate, fluid, getAlias, method, sqlFunction, toColumn, toRelation, variadic, _i, _j, _len, _len1, _ref, _ref1, _ref2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

SUDQuery = require('./sud');

_ref = require('../nodes'), Node = _ref.Node, getAlias = _ref.getAlias, Select = _ref.Select, And = _ref.And, Join = _ref.Join, toRelation = _ref.toRelation, toColumn = _ref.toColumn, sqlFunction = _ref.sqlFunction, JOIN_TYPES = _ref.JOIN_TYPES;

module.exports = SelectQuery = (function(_super) {

  __extends(SelectQuery, _super);

  /*
    Adds a number of SELECT-specific methods to :class:`queries/sud::SUDQuery`,
    such as `fields` and `groupBy`
  */


  function SelectQuery() {
    return SelectQuery.__super__.constructor.apply(this, arguments);
  }

  SelectQuery.rootNode = Select;

  SelectQuery.prototype.fields = function(fields) {
    /*
        Adds one or more fields to the query. Fields can be strings (in which case
        they will be passed to :meth:`queries/sud::SUDQuery.column`) or pre-
        constructed nodes. (Such as those returned by ``column``).
    
        If no fields are given, clears all fields from the currently focused table.
    
        To alias a field, use an object with a single key where the key is the alias
        name and the value is a string or node::
    
          q.fields({employee_name: 'employees.name'})
    */

    var alias, col, f, rel, _i, _len,
      _this = this;
    if (fields.length === 0) {
      rel = this.q.relations.active;
      this.q.projections.prune(function(p) {
        return p.rel() === rel;
      });
      return;
    }
    col = function(o) {
      if (o instanceof Node) {
        return o;
      } else {
        return _this.column(o);
      }
    };
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      f = fields[_i];
      if (alias = getAlias(f)) {
        f = f[alias];
        this.q.projections.addNode(col(f).as(alias));
      } else {
        this.q.projections.addNode(col(f));
      }
    }
    return null;
  };

  SelectQuery.prototype.func = function(fun, args) {
    /*
        Adds a SQL function to the column list for the query. This can be an
        aggregate function if you also use :meth:`queries/select::groupBy`.
    
        :param fun: name of SQL function.
        :param args: arguments that will be passed to the function. Any argument
          that is not a `Node` object will be converted into a bound parameter.
    
        Example::
    
          # SELECT count(id) FROM t1
          select('t1', function (q) { q.func('count', q.c('id')) })
    
          # SELECT count(id) AS "counter" FROM t1
          select('t1', function (q) { q.func({counter: 'count'}, q.c('id')) })
    */

    var alias;
    if (alias = getAlias(fun)) {
      return this.q.projections.addNode(sqlFunction(fun[alias], args).as(alias));
    } else {
      return this.q.projections.addNode(sqlFunction(fun, args));
    }
  };

  SelectQuery.prototype.distinct = function(bool) {
    /*
        Make this query DISTINCT on *all* fields.
    */
    return this.q.distinct.enable = bool;
  };

  SelectQuery.prototype.join = function(table, opts) {
    var fieldList, join, prefix, relation, type;
    if (opts == null) {
      opts = {};
    }
    /*
        Join another table to the query.
    
        :param table: A table name, or alias literal. An error will be thrown if
          the table/alias name is not unique. See :func:`nodes::toRelation` for
          more information on the many things ``table`` could be.
        :param opts.on:
          An object literal expressing join conditions. See
          :meth:`queries/select::SelectQuery::where` for more.
        :param opts.type: A join type constant (e.g. INNER, OUTER)
        :param opts.fields: Columns to be selected from the newly joined table.
        :param opts.prefixFields: If this is a string, it will be used to prefix
          the field names given in ``opts.fields``. If this is a boolean ``true``
          then the joined table (or alias) name plus an underscore will be used
          as the prefix. For example::
    
              query.join({p: 'people'}, {
                on: query.c('people.dep_id').eq(query.c('dep.id')),
                fields: ['first_name', 'last_name'],
                prefixFields: true
              })
    
          Will alias ``people.first_name AS p_first_name``.
    */

    relation = toRelation(table);
    if (this.q.relations.get(relation, false)) {
      throw new Error("Table/alias " + (relation.ref()) + " is not unique!");
    }
    type = opts.type || JOIN_TYPES.INNER;
    if (!(type instanceof JOIN_TYPES.INNER.constructor)) {
      throw new Error("Invalid join type " + type + ", try the constant types exported in the base module (e.g. INNER).");
    }
    join = new Join(type, relation);
    this.q.relations.addNode(join);
    if (opts.on) {
      join.on(new And(this._makeClauses(opts.on)));
    }
    if ((fieldList = opts.fields) != null) {
      if (opts.prefixFields) {
        if (opts.prefixFields === true) {
          prefix = relation.ref() + '_';
        } else {
          prefix = opts.prefixFields;
        }
        fieldList = fieldList.map(function(f) {
          return toColumn(relation, f).as(prefix + f);
        });
      }
      return this.fields(fieldList);
    }
  };

  SelectQuery.prototype.ensureJoin = function(table, opts) {
    var rel;
    if (opts == null) {
      opts = {};
    }
    /*
        The same as :meth:`join`, but will only join ``tbl`` if it is **not**
        joined already.
    */

    rel = toRelation(table);
    if (!this.q.relations.get(rel.ref(), false)) {
      return this.join(rel, opts);
    }
  };

  SelectQuery.prototype.focus = function(alias) {
    /*
        Make a different table "focused", this will use that table as the default
        for the ``fields``, ``order`` and ``where`` methods.
    
        :param alias: The table/alias name to focus. If the table or alias is not
          already part of the query an error will be thrown.
    */
    return this.q.relations["switch"](alias);
  };

  SelectQuery.prototype.groupBy = function(fields) {
    /* Add a GROUP BY to the query.
    */

    var field, _i, _len;
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      this.q.groupBy.addNode(field instanceof Node ? field : this.column(field));
    }
    return null;
  };

  SelectQuery.prototype.having = function(constraint) {
    /*
        This method works similarly to :meth:`queries/sud::SUDQuery.where`, but the
        constraints are added the `HAVING` portion of a SQL clause.
    */

    var node, _i, _len, _ref1, _results;
    _ref1 = this._makeClauses(constraint);
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      _results.push(this.q.having.addNode(node));
    }
    return _results;
  };

  return SelectQuery;

})(SUDQuery);

fluid = require('../decorators/fluid');

variadic = require('../decorators/variadic');

deprecate = require('../decorators/deprecate');

_ref1 = ['fields', 'groupBy'];
for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
  method = _ref1[_i];
  SelectQuery.prototype[method] = variadic(SelectQuery.prototype[method]);
}

_ref2 = ['distinct', 'fields', 'func', 'join', 'ensureJoin', 'focus', 'groupBy', 'having'];
for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
  method = _ref2[_j];
  SelectQuery.prototype[method] = fluid(SelectQuery.prototype[method]);
}

SelectQuery.prototype.field = SelectQuery.prototype.fields;

SelectQuery.prototype.agg = deprecate.rename(SelectQuery.prototype.func, ".agg", ".func");

},{"../decorators/deprecate":1,"../decorators/fluid":2,"../decorators/variadic":3,"../nodes":7,"./sud":14}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
var And, BaseQuery, CONST_NODES, Column, Node, Or, Ordering, SUDQuery, deprecate, fluid, method, nodes, toField, variadic, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseQuery = require('./base');

nodes = require('../nodes');

Node = nodes.Node, And = nodes.And, Or = nodes.Or, Ordering = nodes.Ordering, Column = nodes.Column, CONST_NODES = nodes.CONST_NODES, toField = nodes.toField;

module.exports = SUDQuery = (function(_super) {

  __extends(SUDQuery, _super);

  function SUDQuery() {
    return SUDQuery.__super__.constructor.apply(this, arguments);
  }

  /*
    SUDQuery is the base class for SELECT, UPDATE, and DELETE queries. It adds
    logic to :class:`queries/base::BaseQuery` for adding WHERE clauses, projecting
    columns, ordering, limits, and offsets.
  */


  SUDQuery.prototype.where = function(constraint) {
    /*
        Adds a WHERE clause to the query. This method accepts wide range of input
        that can express very complex constraints. The examples below assume we are
        starting with this simple select query: ``q = select('t1')``
    
        The first kind of constraint is a comparison node as produced by the
        :class:`nodes::ComparableMixin` methods on projected fields::
    
          q.where(q.c('field1').eq(42))
          q.where(q.c('field2').gt(42))
          # WHERE t1.field1 = 42 AND t1.field2 > 42
    
        We used an implied table name above, which is always the last table added to
        the query or focused with  :meth:`queries/sud::SUDQuery.focus`. If you want
        to specify constraints on multiple tables at once (or just be more explicit)
        you can also specify the relation for a field by prepending it to the field
        name (e.g. ``q.c('t1.field1')``. See :meth:`queries/sud::SUDQuery.project`
        for details.
    
        The second kind of constraint is an object literal where each key is a field
        name and each value is a constraint. The last example expressed as a literal
        object looks like this::
    
          q.where({field1: 42, field2: {gt: 42}})
          # WHERE t1.field1 = 42 AND t1.field2 > 42
    
        Internally this constructs the comparison nodes for you using a simple
        transformation: each key is passed to :meth:`project` (meaning you can
        specify the relation name as part of the key if you so desire) and each
        value is either used as the argument to :meth:`nodes::ComparableMixin.eq`
        or (in the case of object literals) converted into one or more calls to
        the corresponding comparison methods.
    
        To compare two fields, use a projection as the value to be compared::
    
          p = q.project.bind(q, 't1')
          q.where({field1: {gt: p('field2')}})
          # WHERE t1.field1 > t1.field2
    
        If you use either of the special keys ``'and'`` or ``'or'`` in an object,
        the value will be treated as a nested set of constraints to be joined with
        the corresponding SQL operator. This process is recursive so you can nest
        constraints arbitrarily deep::
    
          q.where({or: {a: 1, and: {b: 2, c: 3}}})
          # WHERE (t1.a = 1 OR (t1.b = 2 AND t1.c = 3))
    
        You can also acheive the same effect by chaining method calls on comparison
        nodes::
    
          a = q.c('a')
          b = q.c('b')
          c = q.c('c')
          q.where(a.eq(1).or(b.eq(2).and(c.eq(3))))
          # WHERE (t1.a = 1 OR (t1.b = 2 AND t1.c = 3))
    
        If you have the need to mix both styles (or simply find it more readable,
        You can use an array of constraints as the value for ``'or'`` or ``'and'``::
    
          q.where({or: [{a: 1}, b.eq(2).and(c.eq(3))]})
    
        Note that currently you **cannot** pass an object literal to the ``.and``
        and ``.or`` methods::
    
          # Will not work!!
          q.where(a.eq(1).or({b: 2, c: 3}))
    
        Finally, there are also shortcut methods :meth:`queries/sud::SUDQuery.and`
        and :meth:`queries/sud::SUDQuery.or` that treat multiple arguments like an
        array of constraints.
    */

    var node, _i, _len, _ref, _results;
    _ref = this._makeClauses(constraint);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      _results.push(this.q.where.addNode(node));
    }
    return _results;
  };

  SUDQuery.prototype._makeClauses = function(constraint) {
    /*
        Return an array of Binary, And, and Or nodes for this constraint object
    */

    var clauses, column, field, item, op, predicate, val, _i, _len;
    clauses = [];
    if (Array.isArray(constraint)) {
      for (_i = 0, _len = constraint.length; _i < _len; _i++) {
        item = constraint[_i];
        if (item instanceof Node) {
          clauses.push(item);
        } else {
          clauses = clauses.concat(this._makeClauses(item));
        }
      }
      return clauses;
    }
    if (constraint instanceof Node) {
      return [constraint];
    }
    for (field in constraint) {
      predicate = constraint[field];
      if (predicate === void 0) {
        continue;
      } else if (field === 'and') {
        clauses.push(new And(this._makeClauses(predicate)));
      } else if (field === 'or') {
        clauses.push(new Or(this._makeClauses(predicate)));
      } else {
        column = this.column(field);
        if (predicate === null) {
          clauses.push(column.compare('IS', CONST_NODES.NULL));
        } else if (predicate.constructor === Object) {
          for (op in predicate) {
            val = predicate[op];
            clauses.push(column.compare(op, val));
          }
        } else {
          clauses.push(column.eq(predicate));
        }
      }
    }
    return clauses;
  };

  SUDQuery.prototype.or = function(clauses) {
    /* Shortcut for ``.where({or: clauses})``
    */
    return this.where({
      or: clauses
    });
  };

  SUDQuery.prototype.and = function(clauses) {
    /* Shortcut for ``.where({and: clauses})``
    */
    return this.where({
      and: clauses
    });
  };

  SUDQuery.prototype.order = function(args) {
    /*
        Add one or more ORDER BY clauses to the query.
    
        Each ordering can either be a string, in which case it must be a valid-ish
        SQL snippet like 'some_table.some_field DESC', (the field name and direction
        will still be converted to AST nodes) or an object, in which case each key
        will be treated as a field and each value as a direction.
    */

    var direction, name, orderBy, orderings, rel, _i, _len, _ref, _results;
    rel = this.defaultRel();
    orderings = [];
    _results = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      orderBy = args[_i];
      _ref = (function() {
        if (typeof orderBy === 'string') {
          return orderBy.split(' ');
        } else if (!orderBy || typeof orderBy !== 'object') {
          throw new Error("Can't turn " + orderBy + " into an ordering");
        } else if (Array.isArray(orderBy)) {
          return orderBy;
        } else {
          return [orderBy, ''];
        }
      })(), name = _ref[0], direction = _ref[1];
      direction = (function() {
        switch ((direction || '').toLowerCase()) {
          case 'asc':
          case 'ascending':
            return 'ASC';
          case 'desc':
          case 'descending':
            return 'DESC';
          case '':
            return '';
          default:
            throw new Error("Unsupported ordering direction " + direction);
        }
      })();
      if (!name) {
        throw new Error("No name given for ordering " + orderBy);
      } else if (typeof name === 'string') {
        _results.push(this.q.orderBy.addNode(new Ordering(this.column(name), direction)));
      } else if (name instanceof Node) {
        _results.push(this.q.orderBy.addNode(new Ordering(name, direction)));
      } else {
        _results.push(this.order(Object.keys(name).map(function(n) {
          return [n, name[n]];
        })));
      }
    }
    return _results;
  };

  SUDQuery.prototype.limit = function(l) {
    /* Set the LIMIT on this query
    */
    return this.q.limit.value = l;
  };

  SUDQuery.prototype.offset = function(l) {
    /* Set the OFFSET of this query
    */
    return this.q.offset.value = l;
  };

  SUDQuery.prototype.defaultRel = function() {
    return this.q.relations.active;
  };

  SUDQuery.prototype.project = function() {
    /* Backwards compatible alias for :meth:`queries/sud::SUDQuery.column`
    */
    return this.column.apply(this, arguments);
  };

  SUDQuery.prototype.column = function(relation, field) {
    /*
        Return a :class:`nodes::Column` node representing ``<relation>.<field>``.
    
        The first argument is optional and specifies a table or alias name referring
        to a relation already joined to this query. If you don't specify a relation,
        the table added or focused last will be used. Alternatively, you can specify
        the relation name and field with a single dot-separated string::
    
          q.column('departments.name') == q.column('departments', 'name')
    
        The returned object has a methods from :class:`nodes::ComparableMixin` that
        create new comparison nodes usable in join conditions and where clauses::
    
          # Find developers over the age of 45
          s = select('people', ['name'])
          s.join('departments', on: {id: s.column('people', 'department_id')})
          s.where(s.column('departments', 'name').eq('development'))
          s.where(s.column('people', 'age').gte(45))
    
        ``project`` is also aliased as ``p`` for those who value brevity::
    
             q.where(q.c('departments.name').eq('development'))
    
        .. note:: this means you *must* specify a relation name if you have a field
          name with a dot in it, if you have dots in your column names, sorry.
    */

    var parts, proj, _ref;
    if (field != null) {
      field = toField(field);
      if (typeof relation === 'string') {
        return new Column(this.q.relations.get(relation), field);
      } else {
        relation = this.q.relations.get(toRelation(relation).ref());
        return new Column(relation, field);
      }
    } else if (typeof relation === 'string') {
      parts = relation.split('.');
      if (parts.length === 2) {
        return new Column(this.q.relations.get(parts[0]), toField(parts[1]));
      } else {
        return new Column(this.defaultRel(), toField(relation));
      }
    } else if (relation instanceof Column) {
      proj = relation;
      this.q.relations.get((_ref = proj.source) != null ? _ref.ref() : void 0);
      return proj;
    } else {
      throw new Error("Can't make a projection from object: " + relation);
    }
  };

  SUDQuery.prototype.rel = function(alias) {
    /* A shorthand way to get a relation by (alias) name
    */
    return this.q.relations.get(alias);
  };

  return SUDQuery;

})(BaseQuery);

deprecate = require('../decorators/deprecate');

variadic = require('../decorators/variadic');

fluid = require('../decorators/fluid');

_ref = ['and', 'or', 'order'];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  method = _ref[_i];
  SUDQuery.prototype[method] = variadic(SUDQuery.prototype[method]);
}

_ref1 = ['where', 'or', 'and', 'limit', 'offset', 'order'];
for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
  method = _ref1[_j];
  SUDQuery.prototype[method] = fluid(SUDQuery.prototype[method]);
}

_ref2 = ['p', 'project'];
for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
  method = _ref2[_k];
  SUDQuery.prototype[method] = deprecate.rename(SUDQuery.prototype.column, method, ".column or .c");
}

SUDQuery.prototype.c = SUDQuery.prototype.column;

},{"../decorators/deprecate":1,"../decorators/fluid":2,"../decorators/variadic":3,"../nodes":7,"./base":8}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
var SUDQuery, Update, UpdateQuery, binaryOp, fluid, method, returnable, toField, toParam, variadic, _i, _len, _ref, _ref1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

returnable = require('./returnable');

SUDQuery = require('./sud');

_ref = require('../nodes'), Update = _ref.Update, binaryOp = _ref.binaryOp, toField = _ref.toField, toParam = _ref.toParam;

module.exports = UpdateQuery = (function(_super) {

  __extends(UpdateQuery, _super);

  /*
    The update query is a little underpowered right now, and can only handle
    simple updates of a single table.
  */


  function UpdateQuery() {
    return UpdateQuery.__super__.constructor.apply(this, arguments);
  }

  UpdateQuery.rootNode = Update;

  returnable(UpdateQuery);

  UpdateQuery.prototype.set = function(data) {
    /*
        Add fields to the SET portion of this query.
    
        :param data: An object mapping fields to values. The values will be passed
          to :func:`nodes::toParam` to be converted into bound paramaeters.
    */

    var field, value, _results;
    _results = [];
    for (field in data) {
      value = data[field];
      _results.push(this.q.updates.addNode(binaryOp(toField(field), '=', toParam(value))));
    }
    return _results;
  };

  UpdateQuery.prototype.setNodes = function(nodes) {
    /* Directly push one or more nodes into the SET portion of this query
    */

    var _ref1;
    return (_ref1 = this.q.updates).push.apply(_ref1, nodes);
  };

  UpdateQuery.prototype.defaultRel = function() {
    return this.q.relation;
  };

  return UpdateQuery;

})(SUDQuery);

fluid = require('../decorators/fluid');

variadic = require('../decorators/variadic');

UpdateQuery.prototype.setNodes = variadic(UpdateQuery.prototype.setNodes);

_ref1 = ['set', 'setNodes', 'returning'];
for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
  method = _ref1[_i];
  UpdateQuery.prototype[method] = fluid(UpdateQuery.prototype[method]);
}

},{"../decorators/fluid":2,"../decorators/variadic":3,"../nodes":7,"./returnable":12,"./sud":14}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
var unmarshal, unmarshallable;

unmarshallable = Object.create(require('./nodes'), {
  InsertQuery: {
    value: require('./queries/insert')
  },
  SelectQuery: {
    value: require('./queries/select')
  },
  UpdateQuery: {
    value: require('./queries/update')
  },
  DeleteQuery: {
    value: require('./queries/delete')
  }
});

unmarshal = null;

module.exports = function(visitor, object) {
  var path, recur;
  path = [];
  recur = function(object, k) {
    var ctor, err, result, type, v, _ref;
    if (k == null) {
      k = "";
    }
    if (typeof object !== 'object') {
      return object;
    }
    path.push(k);
    if (Array.isArray(object)) {
      result = object.map(recur);
    } else {
      if (!(type = object._type)) {
        result = {};
        for (k in object) {
          v = object[k];
          result[k] = recur(v, k);
        }
        result;

      } else if (((_ref = (ctor = unmarshallable[type])) != null ? _ref.unmarshal : void 0) != null) {
        if (visitor != null) {
          if (typeof visitor.before === "function") {
            visitor.before(object, path);
          }
        }
        result = ctor.unmarshal(object, recur);
        if (visitor != null) {
          if (typeof visitor.after === "function") {
            visitor.after(result, path);
          }
        }
      } else {
        err = new Error("Cannot unmarshall " + type + " @ " + (path.join('/')));
        err.path = path.slice();
        path = [];
        throw err;
      }
    }
    path.pop(k);
    return result;
  };
  if (arguments.length > 1) {
    return recur(object);
  } else {
    return recur;
  }
};

module.exports.allow = unmarshallable;

},{"./nodes":7,"./queries/delete":9,"./queries/insert":11,"./queries/select":13,"./queries/update":15}],17:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],18:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],19:[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

},{"wrappy":18}],20:[function(require,module,exports){
var process=require("__browserify_process");var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')

module.exports = StateMachine
module.exports.IllegalTransitionError = IllegalTransitionError;
module.exports.UndefinedMethodError = UndefinedMethodError;

inherits(StateMachine, EventEmitter)
function StateMachine (initialState, transitions) {
  EventEmitter.call(this)

  var currentState = initialState;

  this.state = function (to) {
    if (!to) return currentState;

    if (to === currentState) return;

    var extra = Array.prototype.slice.call(arguments, 1)
      , legal = transitions[currentState]
      ;

    if (legal && legal.indexOf(to) > -1) {
      this.emit('transition', currentState, to);
      currentState = to;
      this.emit(currentState)
    } else {
      return new IllegalTransitionError(currentState, to);
    }
  }
}

StateMachine.method = function (name, implementations) {
  dispatch.implementations = {};
  for (var key in implementations) {
    var states = key.split('|');
    while (states.length) {
      var state = states.shift();
      dispatch.implementations[state] = implementations[key];
    }
  }
  return dispatch;

  function dispatch () {
    var implementation = dispatch.implementations[this.state()];
    if (typeof implementation !== 'function') {
      var error = new StateMachine.UndefinedMethodError(name, this.state());
      var lastArg = [].slice.call(arguments).pop();
      if (typeof lastArg === 'function') {
        lastArg.call(this, error);
      } else {
        var self = this;
        process.nextTick(function () {
          self.emit('error', error);
        })
      }
      return;
    }
    return implementation.apply(this, arguments);
  }
}


inherits(UndefinedMethodError, Error);
function UndefinedMethodError(method, state) {
  Error.captureStackTrace(this, UndefinedMethodError);
  this.name = 'Undefined Method';
  this.message = "method '" + method + "' unavailable in state '" + state + "'";
}

inherits(IllegalTransitionError, Error);
function IllegalTransitionError(from, to) {
  Error.captureStackTrace(this, IllegalTransitionError);
  this.name = 'Illegal Transition';
  this.message = "Transition from '" + from + "' to '" + to + "' not allowed";
}

},{"__browserify_process":33,"events":24,"inherits":17}],21:[function(require,module,exports){
var process=require("__browserify_process");var inherits = require('inherits')
var FSM = require('yafsm')
var once = require('once')

module.exports = begin
begin.Transaction = Transaction

function begin (queryable, options, beginStatement, callback) {
  if (typeof options != 'object') {
    callback = beginStatement;
    beginStatement = options;
    options = {};
  }

  if (undefined === options.autoRollback) {
    options.autoRollback = true;
  }

  if (typeof beginStatement == 'function') {
    callback = beginStatement
    beginStatement = undefined
  }

  if (queryable instanceof Transaction) {
    return beginWithParent(queryable, options, callback)
  }

  var adapter = queryable.adapter;

  var tx = new Transaction({
    adapter:      adapter,
    begin:        beginStatement,
    callback:     callback,
    autoRollback: options.autoRollback
  })

  if (typeof adapter.createQuery != 'function' ||
      typeof queryable.query != 'function') {
    var error = new TypeError(queryable + ' is not a queryable!')
    if (callback) {
      callback(error)
    } else {
      throw error
    }
  }

  if (typeof queryable.acquire == 'function') {
    // it's a pool
    var pool = queryable
    pool.acquire(function (err, conn) {
      if (err) return process.nextTick(function () {
        tx.emit('error', err)
      })
      var release = pool.release.bind(pool, conn)
      tx.on('query', pool.emit.bind(pool, 'query'))
      tx.once('rollback:complete', release)
        .once('commit:complete', release)
        .setConnection(conn)
    })
  }
  else {
    // it's a connection
    tx.setConnection(queryable)
  }

  return tx
}

inherits(Transaction, FSM)
function Transaction(opts) {
  opts = opts || {}
  this.adapter = opts.adapter
  this._connection = null
  this._statements = {
    begin:    opts.begin    || 'BEGIN',
    commit:   opts.commit   || 'COMMIT',
    rollback: opts.rollback || 'ROLLBACK'
  }
  this._queue = []
  this._nestingLevel = opts.nestingLevel || 0
  this._autoRollback = opts.autoRollback;

  this._emitQuery = function (query) { this.emit('query', query) }.bind(this)
  this.handleError = this.handleError.bind(this)

  FSM.call(this, 'disconnected', {
    'disconnected': [ 'connected' ],
    'connected':    [ 'open', 'closed' ],
    'open':         [ 'connected', 'closed' ]
  })

  if (opts.callback) {
    var callback = opts.callback
    this
      .once('error', callback)
      .once('begin:complete', function () {
        this.removeListener('error', callback)
        callback(null, this)
      })
  }
}

Transaction.prototype.handleError = function (err, skipEmit) {
  var self = this
  var rollback = this.rollback.implementations['open']
  if (this.state() !== 'closed' && this._connection && this._autoRollback) {
    rollback.call(this, function (rollbackErr) {
      if (rollbackErr) {
        rollbackErr.previous = err;
        self.emit('error', rollbackErr)
      }
      else if (!skipEmit) {
        self.emit('error', err)
      }
    }, err)
  }
  else if (!skipEmit) self.emit('error', err)
}

Transaction.prototype.query = FSM.method('query', {
  'connected|disconnected': function (text, params, callback) {
    var query = this.adapter.createQuery(text, params, callback)
    this._queue.push(query)
    return query
  },
  'open': function (text, params, callback) {
    var self = this
    var query = this.adapter.createQuery(text, params, callback)
    query.once('error', function (err) {
      self.handleError(err, query.listeners('error').length)
    })
    return this._connection.query(query)
  }
})

;['commit', 'rollback'].forEach(function (methodName) {
  Transaction.prototype[methodName] = FSM.method(methodName, {
    'open': closeVia(methodName),
    'connected|disconnected': function (callback) {
      var fn = this[methodName].implementations['open']
      this._queue.push([fn, [callback]])
      return this
    }
  })
})

Transaction.prototype.setConnection = FSM.method('setConnection', {
  'disconnected': function (connection) {
    var self = this
    var err = self.state('connected')
    if (err) {
      process.nextTick(function () {
        self.emit('error', err)
      })
      return
    }

    self._connection = connection
    self._addConnectionListeners()

    self.emit('begin:start')
    var beginQuery = connection.query(self._statements.begin, function (err) {
      if (err) return self.handleError(err)
      self.emit('begin:complete') // removes error listener
      self._runQueue()
    })

    self.emit('query', beginQuery)
    return self
  }
})

Transaction.prototype._runQueue = function () {
  var self = this
  return next()

  function next (err, skipEmit) {
    if (err) {
      self.handleError(err, skipEmit)
    }
    if (!self._queue.length) {
      if (self.state() !== 'closed' && (err = self.state('open'))) {
        self.handleError(err)
      }
      return
    }

    var task = self._queue.shift()

    if (Array.isArray(task)) {
      runFunctionCall(self, task, next)
    } else if (task instanceof Transaction) {
      runChildTransaction(self, task)
    } else {
      runQueuedQuery(self, task, next)
    }
  }
}

function runFunctionCall (ctx, fnAndArgs, next) {
  var fn = fnAndArgs[0]
    , args = fnAndArgs[1]
    , last = args[args.length - 1]

  if (typeof last == 'function') {
    args[args.length - 1] = function (err) {
      if (err) return last(err)
      last.apply(this, arguments)
      next()
    }
  } else {
    args.push(next)
  }

  return fn.apply(ctx, args)
}

function runQueuedQuery (self, query, next) {
  if (self.state() == 'closed') {
    self.query(query, function (err) {
      query.emit('error', err)
      next()
    })
    return
  }
  self._connection.query(query)
  var onext = once(next) // ensure we only call `next` once
  query.once('error', function (err) {
    onext(err, this.listeners('error').length)
  })
  query.once('close', function () {
    // let 'error' events have a chance to call `next` first
    process.nextTick(onext)
  })
}

function beginWithParent (parent, options, callback) {
  var child = createChildTransaction(parent, options, callback)
  switch (parent.state()) {
    case 'disconnected':
    case 'connected':
      parent._queue.push(child)
      break
    case 'open':
      runChildTransaction(parent, child)
      break
    case 'closed':
      var error = new Error("Cannot start child transaction on parent in state 'closed'")
      process.nextTick(function () {
        // callback is already attached to error event
        child.emit('error', error)
      })
  }
  return child
}

function createChildTransaction (parent, options, callback) {
  var nestingLevel = parent._nestingLevel + 1
  var savepointName = 'sp_' + nestingLevel

  var child = new Transaction({
    adapter:      parent.adapter,
    nestingLevel: nestingLevel,
    callback:     callback,
    begin:        'SAVEPOINT '         + savepointName,
    commit:       'RELEASE SAVEPOINT ' + savepointName,
    rollback:     'ROLLBACK TO '       + savepointName,
    autoRollback: options.autoRollback,
  })

  child
    .on('query', parent._emitQuery)
    .once('connected', function () {
      parent._removeConnectionListeners()
      parent.state('connected')
    })
    .once('close', function () {
      parent._addConnectionListeners()
      parent._runQueue()
    })

  return child
}

function runChildTransaction (parent, child) {
  // Child transaction
  child.setConnection(parent._connection)
  child.on('error', function (err) {
    if (child.listeners('error').length == 1) {
      // if a child transaction errors, and the parent is the only
      // listener, it should re-emit the error, but *not* roll back
      parent.emit('error', err)
    }
  })
}

Transaction.prototype._addConnectionListeners = function () {
  this._connection.on('error', this.handleError)
  this._connection.on('query', this._emitQuery)
}

Transaction.prototype._removeConnectionListeners = function () {
  this._connection.removeListener('error', this.handleError)
  this._connection.removeListener('query', this._emitQuery)
}

function closeVia (action) {
  return function (callback) {
    var self = this
    if (self.state() == 'closed') {
      return
    }
    var err = self.state('closed')
    if (err) {
      return self.handleError(err, callback)
    }
    self.emit(action + ':start')
    var q = self._connection.query(self._statements[action], function (err) {
      self._removeConnectionListeners()
      self._connection = null
      if (err) {
        self.handleError(new CloseFailedError(err, action), callback)
      } else {
        self.emit(action + ':complete')
        self.emit('close')
        if (callback) callback()
      }
    })
    return self
  }
}

inherits(CloseFailedError, Error)
function CloseFailedError(err, action) {
  Error.captureStackTrace(this, CloseFailedError)
  this.name = action + ' failed'
  this.message = err.message
  this.previous = null;
}

},{"__browserify_process":33,"inherits":17,"once":19,"yafsm":20}],22:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// UTILITY
var util = require('util');
var shims = require('_shims');
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = shims.keys(a),
        kb = shims.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};
},{"_shims":22,"util":28}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util');

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!util.isNumber(n) || n < 0)
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (util.isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (util.isUndefined(handler))
    return false;

  if (util.isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (util.isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              util.isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (util.isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (util.isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!util.isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  function g() {
    this.removeListener(type, g);
    listener.apply(this, arguments);
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (util.isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (util.isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (util.isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (util.isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (util.isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};
},{"util":28}],25:[function(require,module,exports){

// not implemented
// The reason for having an empty file and not throwing is to allow
// untraditional implementation of this module.

},{}],26:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// Query String Utilities

var QueryString = exports;
var util = require('util');
var shims = require('_shims');
var Buffer = require('buffer').Buffer;

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}


function charCode(c) {
  return c.charCodeAt(0);
}


// a safe fast alternative to decodeURIComponent
QueryString.unescapeBuffer = function(s, decodeSpaces) {
  var out = new Buffer(s.length);
  var state = 'CHAR'; // states: CHAR, HEX0, HEX1
  var n, m, hexchar;

  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {
    var c = s.charCodeAt(inIndex);
    switch (state) {
      case 'CHAR':
        switch (c) {
          case charCode('%'):
            n = 0;
            m = 0;
            state = 'HEX0';
            break;
          case charCode('+'):
            if (decodeSpaces) c = charCode(' ');
            // pass thru
          default:
            out[outIndex++] = c;
            break;
        }
        break;

      case 'HEX0':
        state = 'HEX1';
        hexchar = c;
        if (charCode('0') <= c && c <= charCode('9')) {
          n = c - charCode('0');
        } else if (charCode('a') <= c && c <= charCode('f')) {
          n = c - charCode('a') + 10;
        } else if (charCode('A') <= c && c <= charCode('F')) {
          n = c - charCode('A') + 10;
        } else {
          out[outIndex++] = charCode('%');
          out[outIndex++] = c;
          state = 'CHAR';
          break;
        }
        break;

      case 'HEX1':
        state = 'CHAR';
        if (charCode('0') <= c && c <= charCode('9')) {
          m = c - charCode('0');
        } else if (charCode('a') <= c && c <= charCode('f')) {
          m = c - charCode('a') + 10;
        } else if (charCode('A') <= c && c <= charCode('F')) {
          m = c - charCode('A') + 10;
        } else {
          out[outIndex++] = charCode('%');
          out[outIndex++] = hexchar;
          out[outIndex++] = c;
          break;
        }
        out[outIndex++] = 16 * n + m;
        break;
    }
  }

  // TODO support returning arbitrary buffers.

  return out.slice(0, outIndex - 1);
};


QueryString.unescape = function(s, decodeSpaces) {
  return QueryString.unescapeBuffer(s, decodeSpaces).toString();
};


QueryString.escape = function(str) {
  return encodeURIComponent(str);
};

var stringifyPrimitive = function(v) {
  if (util.isString(v))
    return v;
  if (util.isBoolean(v))
    return v ? 'true' : 'false';
  if (util.isNumber(v))
    return isFinite(v) ? v : '';
  return '';
};


QueryString.stringify = QueryString.encode = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (util.isNull(obj)) {
    obj = undefined;
  }

  if (util.isObject(obj)) {
    return shims.map(shims.keys(obj), function(k) {
      var ks = QueryString.escape(stringifyPrimitive(k)) + eq;
      if (util.isArray(obj[k])) {
        return shims.map(obj[k], function(v) {
          return ks + QueryString.escape(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + QueryString.escape(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return QueryString.escape(stringifyPrimitive(name)) + eq +
         QueryString.escape(stringifyPrimitive(obj));
};

// Parse a key=val string.
QueryString.parse = QueryString.decode = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (!util.isString(qs) || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && util.isNumber(options.maxKeys)) {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    try {
      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);
    } catch (e) {
      k = QueryString.unescape(kstr, true);
      v = QueryString.unescape(vstr, true);
    }

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (util.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};
},{"_shims":22,"buffer":30,"util":28}],27:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = { encode : function (s) { return s } };
var util = require('util');
var shims = require('_shims');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = shims.trim(rest);

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      shims.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && shims.substr(protocol, -1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  shims.forEach(shims.keys(this), function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    shims.forEach(shims.keys(relative), function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      shims.forEach(shims.keys(relative), function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (shims.substr(srcPath.join('/'), -1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};
},{"_shims":22,"querystring":26,"util":28}],28:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.binarySlice === 'function'
  ;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"_shims":22}],29:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],30:[function(require,module,exports){
var assert;
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= require('assert');
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

},{"./buffer_ieee754":29,"assert":23,"base64-js":31}],31:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],32:[function(require,module,exports){

},{}],33:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[6])
(6)
});
;