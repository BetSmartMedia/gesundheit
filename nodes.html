<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Nodes &mdash; gesundheit 0.8.10 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-2.3.2/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/local-overrides.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-2.3.2/css/bootstrap-responsive.min.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.8.10',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.9.1.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-2.3.2/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="gesundheit 0.8.10 documentation" href="index.html" />
    <link rel="next" title="Client-side usage - Experimental" href="client_side_usage.html" />
    <link rel="prev" title="Dialects" href="dialects.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>

        <a class="brand" href="index.html">gesundheit</a>
        <span class="navbar-text pull-left"><b>0.8</b></span>

        <div class="nav-collapse">
          <ul class="nav">
            <li class="divider-vertical"></li>
            
            
              <li class="dropdown globaltoc-container">
  <a href="index.html"
     class="dropdown-toggle"
     data-toggle="dropdown">Contents <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
    ><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="synopsis.html">API summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="query_building_api.html">Query Building API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="engines_and_binding.html">Engines and Binding</a></li>
<li class="toctree-l1"><a class="reference internal" href="dialects.html">Dialects</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="client_side_usage.html">Client-side usage - Experimental</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"><ul>
<li><a class="reference internal" href="#">Nodes</a></li>
</ul>
</ul>
</li>
              
            
            
            
<li>
  <a data-toggle="modal" href="#try-it-modal">Try it now!</a>
</li>

            
          </ul>

          
            
<form class="navbar-search pull-right" action="search.html" method="get">
  <input type="text" name="q" class="search-query" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
      </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="span12">
      
  <div class="section" id="module-nodes::">
<span id="nodes"></span><h1>Nodes<a class="headerlink" href="#module-nodes::" title="Permalink to this headline">¶</a></h1>
<p>These are the classes that represent nodes in the AST for a SQL statement.
Application code should very rarely have to deal with these classes directly;
Instead, the APIs exposed by the various query manager classes are intended to
cover the majority of use-cases.</p>
<p>However, in the spirit of &#8220;making hard things possible&#8221;, all of AST nodes are
exported from this module so you can constructed and assemble them manually if
you need to.</p>
<dl class="class">
<dt id="nodes::Node">
<em class="property">class </em><tt class="descname">Node</tt><a class="headerlink" href="#nodes::Node" title="Permalink to this definition">¶</a></dt>
<dd><p>(Empty) base Node class</p>
</dd></dl>

<dl class="class">
<dt id="nodes::ValueNode">
<em class="property">class </em><tt class="descname">ValueNode</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::Node" title="nodes::Node"><tt class="xref coffee coffee-class docutils literal"><span class="pre">Node</span></tt></a><a class="headerlink" href="#nodes::ValueNode" title="Permalink to this definition">¶</a></dt>
<dd><p>A ValueNode is a literal string that should be printed unescaped.</p>
</dd></dl>

<dl class="class">
<dt id="nodes::IntegerNode">
<em class="property">class </em><tt class="descname">IntegerNode</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::ValueNode" title="nodes::ValueNode"><tt class="xref coffee coffee-class docutils literal"><span class="pre">ValueNode</span></tt></a><a class="headerlink" href="#nodes::IntegerNode" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#nodes::ValueNode" title="nodes::ValueNode"><tt class="xref coffee coffee-class docutils literal"><span class="pre">ValueNode</span></tt></a> that validates it&#8217;s input is an integer.</p>
</dd></dl>

<dl class="class">
<dt id="nodes::Identifier">
<em class="property">class </em><tt class="descname">Identifier</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::ValueNode" title="nodes::ValueNode"><tt class="xref coffee coffee-class docutils literal"><span class="pre">ValueNode</span></tt></a><a class="headerlink" href="#nodes::Identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>An identifier is a column or relation name that may need to be quoted.</p>
</dd></dl>

<dl class="class">
<dt id="nodes::NodeSet">
<em class="property">class </em><tt class="descname">NodeSet</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::Node" title="nodes::Node"><tt class="xref coffee coffee-class docutils literal"><span class="pre">Node</span></tt></a><a class="headerlink" href="#nodes::NodeSet" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of nodes joined together by <tt class="docutils literal"><span class="pre">&#64;glue</span></tt></p>
<dl class="method">
<dt id="nodes::NodeSet.constructor">
<em class="property">method </em><tt class="descname">NodeSet.constructor</tt><big>(</big><em>nodes</em>, <em>glue</em><big>)</big><a class="headerlink" href="#nodes::NodeSet.constructor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>&#64;nodes</strong> &#8211; A list of child nodes.</li>
<li><strong>glue</strong> &#8211; A string that will be used to join the nodes when compileing</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nodes::NodeSet.addNode">
<em class="property">method </em><tt class="descname">NodeSet.addNode</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#nodes::NodeSet.addNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new Node to the end of this set</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nodes::ParenthesizedNodeSet">
<em class="property">class </em><tt class="descname">ParenthesizedNodeSet</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::NodeSet" title="nodes::NodeSet"><tt class="xref coffee coffee-class docutils literal"><span class="pre">NodeSet</span></tt></a><a class="headerlink" href="#nodes::ParenthesizedNodeSet" title="Permalink to this definition">¶</a></dt>
<dd><p>A NodeSet wrapped in parenthesis.</p>
</dd></dl>

<dl class="class">
<dt id="nodes::SqlFunction">
<em class="property">class </em><tt class="descname">SqlFunction</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::Node" title="nodes::Node"><tt class="xref coffee coffee-class docutils literal"><span class="pre">Node</span></tt></a><a class="headerlink" href="#nodes::SqlFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Includes <a class="reference internal" href="#nodes::ComparableMixin" title="nodes::ComparableMixin"><tt class="xref coffee coffee-class docutils literal"><span class="pre">ComparableMixin</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nodes::Parameter">
<em class="property">class </em><tt class="descname">Parameter</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::ValueNode" title="nodes::ValueNode"><tt class="xref coffee coffee-class docutils literal"><span class="pre">ValueNode</span></tt></a><a class="headerlink" href="#nodes::Parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Like a ValueNode, but will render as a bound parameter place-holder
(e.g. <tt class="docutils literal"><span class="pre">$1</span></tt>) and it&#8217;s value will be collected by the dialect when compiling.</p>
</dd></dl>

<dl class="class">
<dt id="nodes::Relation">
<em class="property">class </em><tt class="descname">Relation</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::Identifier" title="nodes::Identifier"><tt class="xref coffee coffee-class docutils literal"><span class="pre">Identifier</span></tt></a><a class="headerlink" href="#nodes::Relation" title="Permalink to this definition">¶</a></dt>
<dd><p>A relation node represents a table name or alias in a statement.</p>
<dl class="method">
<dt id="nodes::Relation.ref">
<em class="property">method </em><tt class="descname">Relation.ref</tt><big>(</big><big>)</big><a class="headerlink" href="#nodes::Relation.ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the table name. Aliased tables return the alias name.</p>
</dd></dl>

<dl class="method">
<dt id="nodes::Relation.project">
<em class="property">method </em><tt class="descname">Relation.project</tt><big>(</big><em>field</em><big>)</big><a class="headerlink" href="#nodes::Relation.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#nodes::Column" title="nodes::Column"><tt class="xref coffee coffee-class docutils literal"><span class="pre">Column</span></tt></a> of <cite>field</cite> from this table.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nodes::RelationAlias">
<em class="property">class </em><tt class="descname">RelationAlias</tt><em class="property"> extends </em><tt class="xref coffee coffee-class docutils literal"><span class="pre">AbstractAlias</span></tt><a class="headerlink" href="#nodes::RelationAlias" title="Permalink to this definition">¶</a></dt>
<dd><p>An aliased <a class="reference internal" href="#nodes::Relation" title="nodes::Relation"><tt class="xref coffee coffee-class docutils literal"><span class="pre">Relation</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="nodes::Field">
<em class="property">class </em><tt class="descname">Field</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::Identifier" title="nodes::Identifier"><tt class="xref coffee coffee-class docutils literal"><span class="pre">Identifier</span></tt></a><a class="headerlink" href="#nodes::Field" title="Permalink to this definition">¶</a></dt>
<dd><p>A column name</p>
</dd></dl>

<dl class="class">
<dt id="nodes::Column">
<em class="property">class </em><tt class="descname">Column</tt><em class="property"> extends </em><tt class="xref coffee coffee-class docutils literal"><span class="pre">FixedNodeSet</span></tt><a class="headerlink" href="#nodes::Column" title="Permalink to this definition">¶</a></dt>
<dd><p>Includes <a class="reference internal" href="#nodes::ComparableMixin" title="nodes::ComparableMixin"><tt class="xref coffee coffee-class docutils literal"><span class="pre">ComparableMixin</span></tt></a></p>
<dl class="method">
<dt id="nodes::Column.as">
<em class="property">method </em><tt class="descname">Column.as</tt><big>(</big><em>alias</em><big>)</big><a class="headerlink" href="#nodes::Column.as" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an aliased version of this column.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nodes::ColumnSet">
<em class="property">class </em><tt class="descname">ColumnSet</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::NodeSet" title="nodes::NodeSet"><tt class="xref coffee coffee-class docutils literal"><span class="pre">NodeSet</span></tt></a><a class="headerlink" href="#nodes::ColumnSet" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of projected columns in a query</p>
</dd></dl>

<dl class="class">
<dt id="nodes::RelationSet">
<em class="property">class </em><tt class="descname">RelationSet</tt><em class="property"> extends </em><a class="reference internal" href="#nodes::NodeSet" title="nodes::NodeSet"><tt class="xref coffee coffee-class docutils literal"><span class="pre">NodeSet</span></tt></a><a class="headerlink" href="#nodes::RelationSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages a set of relations and exposes methods to find them by alias.</p>
</dd></dl>

<dl class="class">
<dt id="nodes::Select">
<em class="property">class </em><tt class="descname">Select</tt><em class="property"> extends </em><tt class="xref coffee coffee-class docutils literal"><span class="pre">Statement</span></tt><a class="headerlink" href="#nodes::Select" title="Permalink to this definition">¶</a></dt>
<dd><p>The root node of a SELECT query</p>
</dd></dl>

<dl class="class">
<dt id="nodes::Update">
<em class="property">class </em><tt class="descname">Update</tt><em class="property"> extends </em><tt class="xref coffee coffee-class docutils literal"><span class="pre">Statement</span></tt><a class="headerlink" href="#nodes::Update" title="Permalink to this definition">¶</a></dt>
<dd><p>The root node of an UPDATE query</p>
</dd></dl>

<dl class="class">
<dt id="nodes::Insert">
<em class="property">class </em><tt class="descname">Insert</tt><em class="property"> extends </em><tt class="xref coffee coffee-class docutils literal"><span class="pre">Statement</span></tt><a class="headerlink" href="#nodes::Insert" title="Permalink to this definition">¶</a></dt>
<dd><p>The root node of an INSERT query</p>
<dl class="method">
<dt id="nodes::Insert.addRowObject">
<em class="property">method </em><tt class="descname">Insert.addRowObject</tt><big>(</big><em>row</em><big>)</big><a class="headerlink" href="#nodes::Insert.addRowObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a row from an object. This will set the column list of the query if it
isn&#8217;t set yet. If it <cite>is</cite> set, then only keys matching the existing column
list will be inserted.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nodes::Delete">
<em class="property">class </em><tt class="descname">Delete</tt><em class="property"> extends </em><tt class="xref coffee coffee-class docutils literal"><span class="pre">Statement</span></tt><a class="headerlink" href="#nodes::Delete" title="Permalink to this definition">¶</a></dt>
<dd><p>The root node of a DELETE query</p>
</dd></dl>

<dl class="class">
<dt id="nodes::ComparableMixin">
<em class="property">class </em><tt class="descname">ComparableMixin</tt><a class="headerlink" href="#nodes::ComparableMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>A mixin that adds comparison methods to a class. Each of these comparison
methods will yield a new AST node comparing the invocant to the argument.</p>
<dl class="method">
<dt id="nodes::ComparableMixin.eq">
<em class="property">method </em><tt class="descname">ComparableMixin.eq</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#nodes::ComparableMixin.eq" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">this</span> <span class="pre">=</span> <span class="pre">other</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="nodes::ComparableMixin.ne">
<em class="property">method </em><tt class="descname">ComparableMixin.ne</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#nodes::ComparableMixin.ne" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">this</span> <span class="pre">!=</span> <span class="pre">other</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="nodes::ComparableMixin.gt">
<em class="property">method </em><tt class="descname">ComparableMixin.gt</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#nodes::ComparableMixin.gt" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">this</span> <span class="pre">&gt;</span> <span class="pre">other</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="nodes::ComparableMixin.lt">
<em class="property">method </em><tt class="descname">ComparableMixin.lt</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#nodes::ComparableMixin.lt" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">this</span> <span class="pre">&lt;</span> <span class="pre">other</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="nodes::ComparableMixin.lte">
<em class="property">method </em><tt class="descname">ComparableMixin.lte</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#nodes::ComparableMixin.lte" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">this</span> <span class="pre">&lt;=</span> <span class="pre">other</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="nodes::ComparableMixin.gte">
<em class="property">method </em><tt class="descname">ComparableMixin.gte</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#nodes::ComparableMixin.gte" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">this</span> <span class="pre">&gt;=</span> <span class="pre">other</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="nodes::ComparableMixin.compare">
<em class="property">method </em><tt class="descname">ComparableMixin.compare</tt><big>(</big><em>op</em>, <em>other</em><big>)</big><a class="headerlink" href="#nodes::ComparableMixin.compare" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">this</span> <span class="pre">op</span> <span class="pre">other</span></tt> <strong>DANGER</strong> <cite>op</cite> is <strong>NOT</strong> escaped!</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nodes::toParam">
<em class="property">function </em><tt class="descname">toParam</tt><big>(</big><em>it</em><big>)</big><a class="headerlink" href="#nodes::toParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Node that can be used as a parameter.</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="query_building_api.html#queries/select::SelectQuery" title="queries/select::SelectQuery"><tt class="xref coffee coffee-class docutils literal"><span class="pre">SelectQuery</span></tt></a> instances will be treated as
un-named sub queries,</li>
<li>Node instances will be returned unchanged.</li>
<li>Arrays will be turned into a <tt class="xref coffee coffee-class docutils literal"><span class="pre">Tuple</span></tt> instance.</li>
</ul>
</div></blockquote>
<p>All other types will be wrapped in a <a class="reference internal" href="#nodes::Parameter" title="nodes::Parameter"><tt class="xref coffee coffee-class docutils literal"><span class="pre">Parameter</span></tt></a> instance.</p>
</dd></dl>

<dl class="function">
<dt id="nodes::toRelation">
<em class="property">function </em><tt class="descname">toRelation</tt><big>(</big><em>it</em><big>)</big><a class="headerlink" href="#nodes::toRelation" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform <tt class="docutils literal"><span class="pre">it</span></tt> into a <a class="reference internal" href="#nodes::Relation" title="nodes::Relation"><tt class="xref coffee coffee-class docutils literal"><span class="pre">Relation</span></tt></a> instance.</p>
<p>This accepts <cite>strings, ``Relation`</cite> and <tt class="docutils literal"><span class="pre">Alias</span></tt> instances, and objects with
a single key-value pair, which will be turned into an <tt class="docutils literal"><span class="pre">Alias</span></tt> instance.</p>
<p>Examples:</p>
<div class="highlight-coffeescript"><div class="highlight"><pre><span class="nx">toRelation</span><span class="p">(</span><span class="s">&#39;table1&#39;</span><span class="p">)</span>     <span class="o">==</span> <span class="k">new</span> <span class="nx">Relation</span><span class="p">(</span><span class="s">&#39;table1&#39;</span><span class="p">)</span>
<span class="nx">toRelation</span><span class="p">(</span><span class="nv">t1: </span><span class="s">&#39;table1&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="k">new</span> <span class="nx">Alias</span><span class="p">(</span><span class="k">new</span> <span class="nx">Relation</span><span class="p">(</span><span class="s">&#39;table1&#39;</span><span class="p">),</span> <span class="s">&#39;t1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Throws Errors</strong> if the input is not valid.</p>
</dd></dl>

<dl class="function">
<dt id="nodes::toColumn">
<em class="property">function </em><tt class="descname">toColumn</tt><big>(</big><em>relation</em>, <em>field</em><big>)</big><a class="headerlink" href="#nodes::toColumn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new <a class="reference internal" href="#nodes::Column" title="nodes::Column"><tt class="xref coffee coffee-class docutils literal"><span class="pre">Column</span></tt></a> instance.</p>
<p>The first argument is optional and specifies a table (or alias) name.
Alternatively, you can specify the relation name and field with a single
dot-separated string:</p>
<div class="highlight-coffeescript"><div class="highlight"><pre><span class="nx">toColumn</span><span class="p">(</span><span class="s">&#39;departments.name&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">toColumn</span><span class="p">(</span><span class="s">&#39;departments&#39;</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Either argument can be an pre-constructed node object (of the correct type).</p>
</dd></dl>

<dl class="function">
<dt id="nodes::sqlFunction">
<em class="property">function </em><tt class="descname">sqlFunction</tt><big>(</big><em>name</em>, <em>args</em><big>)</big><a class="headerlink" href="#nodes::sqlFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new SQL function call node. For example:</p>
<p>count = g.sqlFunction(&#8216;count&#8217;, [g.text(&#8216;*&#8217;)])</p>
</dd></dl>

<dl class="function">
<dt id="nodes::func">
<em class="property">function </em><tt class="descname">func</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#nodes::func" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a factory for calling the given SQL function. Example:</p>
<div class="highlight-coffeescript"><div class="highlight"><pre><span class="nv">count = </span><span class="nx">g</span><span class="p">.</span><span class="nx">func</span><span class="p">(</span><span class="s">&#39;count&#39;</span><span class="p">)</span>
<span class="nx">count</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The returned factory accepts any number of parameters:</p>
<div class="highlight-coffeescript"><div class="highlight"><pre><span class="nv">substringIndex = </span><span class="nx">g</span><span class="p">.</span><span class="nx">func</span><span class="p">(</span><span class="s">&#39;SUBSTRING_INDEX&#39;</span><span class="p">)</span>
<span class="nx">substringIndex</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="s">&#39;mycol&#39;</span><span class="p">),</span> <span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># SUBSTRING_INDEX(mycol, &#39;-&#39;, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nodes::getAlias">
<em class="property">function </em><tt class="descname">getAlias</tt><big>(</big><em>o</em><big>)</big><a class="headerlink" href="#nodes::getAlias" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <tt class="docutils literal"><span class="pre">o</span></tt> is an object literal representing an alias, and return the
alias name if it is.</p>
</dd></dl>

<dl class="function">
<dt id="nodes::text">
<em class="property">function </em><tt class="descname">text</tt><big>(</big><em>rawSQL</em>, <em>bindVals</em><big>)</big><a class="headerlink" href="#nodes::text" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a node with a raw SQL string and (optionally) parameters. Useful for
when you want to construct a query that is difficult or impossible with the
normal APIs. <a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<p>To use bound parameters in the SQL string, use <tt class="docutils literal"><span class="pre">$</span></tt> prefixed names, and
pass a <tt class="docutils literal"><span class="pre">bindVals</span></tt> argument with corresponding property names. For example,
<a class="reference internal" href="query_building_api.html#queries/sud::SUDQuery.where" title="queries/sud::SUDQuery.where"><tt class="xref coffee coffee-meth docutils literal"><span class="pre">SUDQuery.where</span></tt></a> doesn&#8217;t (currently) support the SQL
<tt class="docutils literal"><span class="pre">BETWEEN</span></tt> operator, but if you needed it, you could use <tt class="docutils literal"><span class="pre">text</span></tt>:</p>
<div class="highlight-coffeescript"><div class="highlight"><pre><span class="nx">function</span> <span class="nx">peopleInWeightRange</span> <span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">select</span><span class="p">(</span><span class="s">&#39;people&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">where</span><span class="p">(</span><span class="nx">text</span><span class="p">(</span><span class="s">&quot;weight BETWEEN $min AND $max&quot;</span><span class="p">,</span> <span class="p">{</span><span class="nv">min: </span><span class="nx">min</span><span class="p">,</span> <span class="nv">max: </span><span class="nx">max</span><span class="p">}))</span>
    <span class="p">.</span><span class="nx">execute</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because javascript doesn&#8217;t distinguish between array indexing and property
access, it can be more clear to use numbered parameters for such short
snippets:</p>
<div class="highlight-coffeescript"><div class="highlight"><pre><span class="nx">function</span> <span class="nx">peopleInWeightRange</span> <span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">select</span><span class="p">(</span><span class="s">&#39;people&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">where</span><span class="p">(</span><span class="nx">text</span><span class="p">(</span><span class="s">&quot;weight BETWEEN $0 AND $1&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">]))</span>
    <span class="p">.</span><span class="nx">execute</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>If you find yourself using this function often, please <a class="reference external" href="https://github.com/BetSmartMedia/gesundheit/issues/new?title=I%20use%20text()%20for%20blah">open an issue</a>
on Github with details on your use case so <cite>gesundheit</cite> can support it
more elegantly.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nodes::binaryOp">
<em class="property">function </em><tt class="descname">binaryOp</tt><big>(</big><em>left</em>, <em>op</em>, <em>right</em><big>)</big><a class="headerlink" href="#nodes::binaryOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new <tt class="xref coffee coffee-class docutils literal"><span class="pre">Binary</span></tt> node:</p>
<div class="highlight-coffeescript"><div class="highlight"><pre><span class="nx">binaryOp</span><span class="p">(</span><span class="s">&#39;hstore_column&#39;</span><span class="p">,</span> <span class="s">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="nx">toParam</span><span class="p">(</span><span class="nx">y</span><span class="p">))</span>
<span class="c1"># hstore_column -&gt; ?</span>
</pre></div>
</div>
<p>This is for special cases, normally you want to use the methods from
<a class="reference internal" href="#nodes::ComparableMixin" title="nodes::ComparableMixin"><tt class="xref coffee coffee-class docutils literal"><span class="pre">ComparableMixin</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="nodes::exists">
<em class="property">function </em><tt class="descname">exists</tt><big>(</big><em>subquery</em><big>)</big><a class="headerlink" href="#nodes::exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an <tt class="docutils literal"><span class="pre">EXISTS</span> <span class="pre">(&lt;subquery&gt;)</span></tt> node for <cite>where</cite></p>
</dd></dl>

<dl class="function">
<dt id="nodes::notExists">
<em class="property">function </em><tt class="descname">notExists</tt><big>(</big><em>subquery</em><big>)</big><a class="headerlink" href="#nodes::notExists" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <tt class="docutils literal"><span class="pre">NOT</span> <span class="pre">EXISTS</span> <span class="pre">(&lt;subquery&gt;)</span></tt> node for <cite>where</cite></p>
</dd></dl>

<dl class="function">
<dt id="nodes::tuple">
<em class="property">function </em><tt class="descname">tuple</tt><big>(</big><em>input</em><big>)</big><a class="headerlink" href="#nodes::tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new Tuple from an array of nodes. Any item in the array that is
<strong>not</strong> an <cite>instanceof Node</cite> will be turned into a parameter with
<a class="reference internal" href="#nodes::toParam" title="nodes::toParam"><tt class="xref coffee coffee-func docutils literal"><span class="pre">toParam</span></tt></a>.</p>
</dd></dl>

</div>


    </div>
      
  </div>
</div>
  <div id="try-it-modal"
     class="modal hide fade"
     tabindex="-1"
     role="dialog"
     aria-labelledby="try-it-modal-label"
     aria-hidden="true"
    s>
  <div class="modal-header">
    <button type="button" class="close" data-dismiss="modal" aria-hidden="true">×</button>
    <h3 id="try-it-modal-label">Try Gesundheit</h3>
  </div>
  <div class="modal-body">
    <p>All functions exported by gesundheit are available as globals
    below.</p>
    <p>Returning a Gesundheit object (such as a query or AST node) will cause
    it to be compiled and the resulting SQL + parameters displayed</p>
    <textarea class=code
              style="width: 98%; height: 10em; font-family:monospace"
              >return select('t1', ['*'])
  .join('t2', {on: {id: toColumn('t1.t2_id')}})
</textarea>
    <pre class=sql></pre>
    <pre class=params></pre>
  </div>
</div>
<script src="_static/bundle.js"></script>
<script src="_static/try-it-now.js"></script>
</script>
  
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2012, Stephen Sugden.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2b1.<br/>
    </p>
  </div>
</footer>

  </body>
</html>